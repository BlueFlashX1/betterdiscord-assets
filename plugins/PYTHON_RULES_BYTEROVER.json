{
  "title": "Python Code Style Rules and Best Practices",
  "description": "Comprehensive Python coding standards, patterns, and best practices for Matthew's development environment including Flask guidelines, performance optimization, and automation patterns",
  "content": "# Python Code Style Rules\n\n## General Python Standards\n\n- **PEP 8**: Follow PEP 8 style guidelines\n- **Type Hints**: Use type hints for all function signatures where possible\n- **Functional Patterns**: Prefer functional, declarative programming; avoid classes where possible except for Flask views\n- **Modularization**: Prefer iteration and modularization over code duplication\n\n## Flask-Specific Guidelines\n\n### Application Structure\n\n- **Application Factories**: Use Flask application factories for better modularity and testing\n- **Blueprints**: Organize routes using Flask Blueprints (`blueprints/user_routes.py`)\n- **File Structure**: Flask app initialization, blueprints, models, utilities, config\n\n### Error Handling\n\n- **Early Returns**: Handle errors and edge cases at the beginning of functions\n- **Guard Clauses**: Use guard clauses to handle preconditions and invalid states early\n- **Avoid Deep Nesting**: Place happy path last in function for improved readability\n- **No Unnecessary Else**: Use if-return pattern instead of else statements\n\n### Dependencies\n\n- Flask\n- Flask-RESTful (for RESTful API development)\n- Flask-SQLAlchemy (for ORM)\n- Flask-Migrate (for database migrations)\n- Marshmallow (for serialization/deserialization)\n- Flask-JWT-Extended (for JWT authentication)\n\n### Flask Patterns\n\n```python\n# Use Flask's application context appropriately\n# Use blueprints for modularizing the application\n# Implement clear separation of concerns (routes, business logic, data access)\n# Use environment variables for configuration management\n```\n\n## Automation Scripts\n\n- **pyautogui + pytesseract**: For UI automation and OCR\n- **Modular Functions**: Break automation into reusable functions\n- **Error Handling**: Always wrap automation operations in try-catch\n- **Logging**: Implement comprehensive logging for debugging\n\n## Code Organization\n\n- **Separate Files**: Each module/class in separate file\n- **Lowercase with Underscores**: For directories and files (`blueprints/user_routes.py`)\n- **Named Exports**: Favor named exports for routes and utility functions\n- **RORO Pattern**: Receive an Object, Return an Object where applicable\n\n## Documentation\n\n- **Docstrings**: Include docstrings following PEP 257 conventions\n- **Type Hints**: Always include type hints\n- **Comments**: Comment complex logic or non-obvious code\n\n## Performance Optimization\n\n### Code Performance and Speed\n\n1. **Use Built-in Functions and Libraries**\n   - Python's built-in functions and libraries are highly optimized\n   - Prefer built-ins over custom implementations when possible\n   - Examples: `sum()`, `max()`, `min()`, `sorted()`, `any()`, `all()`\n\n2. **Avoid Global Variables**\n   - Global variables can slow down code execution\n   - Use local variables whenever possible\n   - Pass data as function parameters instead\n\n3. **Use List Comprehensions**\n   - List comprehensions are faster than for loops\n   - More concise and perform operations in fewer lines\n   - Example: `[x**2 for x in range(10)]` instead of a for loop\n\n4. **Avoid Recursion When Possible**\n   - Recursive functions can be slow and memory-intensive\n   - Prefer iteration for better performance\n   - Use recursion only when it significantly improves code clarity\n\n5. **Use NumPy and SciPy**\n   - Essential for scientific and mathematical computing\n   - NumPy arrays are faster than Python lists for numerical operations\n   - Use vectorized operations and broadcasting for calculations\n\n6. **Use Cython for Critical Sections**\n   - Cython compiles Python to C for speed\n   - Use for performance-critical code sections\n   - Maintains Python-like syntax while achieving C-like speed\n\n7. **Vectorized Operations**\n   - Use NumPy's vectorized operations instead of loops\n   - Broadcasting allows operations on arrays of different shapes\n   - Significantly faster than Python loops\n\n8. **Concurrency and Parallelism**\n   - Use `multiprocessing` for CPU-bound tasks\n   - Use `threading` for I/O-bound tasks\n   - Use `asyncio` for asynchronous I/O operations\n   - Utilize multiple CPU cores when available\n\n9. **Profiling and Debugging**\n   - Use profilers (`cProfile`, `line_profiler`) to identify bottlenecks\n   - Use debuggers (`pdb`, IDE debuggers) to step through code\n   - Optimize only the sections that are actually slow\n\n10. **Keep Code Simple and Readable**\n    - Simple code is easier to optimize\n    - Readable code is easier to maintain and improve\n    - Premature optimization is the root of all evil\n\n11. **Use Match-Case (Python 3.10+)**\n    - Prefer `match-case` over complex if-else ladders\n    - More readable and often faster\n    - Pattern matching is more efficient\n\n### Advanced Python Features\n\n1. **Decorators**\n   - Modify function/class behavior without changing code\n   - Useful for logging, memoization, timing, caching\n   - Example: `@functools.lru_cache` for function memoization\n\n2. **Generators**\n   - Create iterators without loading entire dataset into memory\n   - Use `yield` instead of `return` for memory efficiency\n   - Perfect for processing large files or data streams\n\n3. **Metaclasses**\n   - Create classes that create other classes\n   - Useful for custom class behavior and metaprogramming\n   - Use sparingly - can make code complex\n\n4. **Coroutines**\n   - Create concurrent and asynchronous code\n   - Lightweight alternative to threads\n   - Use with `async`/`await` syntax\n\n5. **Function Annotations**\n   - Add metadata to functions\n   - Specify argument and return types\n   - Improves code documentation and IDE support\n\n6. **Context Managers**\n   - Handle resources safely (files, sockets, DB connections)\n   - Use `with` statement for automatic cleanup\n   - Implement `__enter__` and `__exit__` methods\n\n7. **Enumerations**\n   - Define named values using `Enum` class\n   - Better than magic numbers or strings\n   - Type-safe and self-documenting\n\n8. **Namedtuples**\n   - Tuples with named fields\n   - Access fields by name instead of index\n   - Lightweight alternative to classes for simple data structures\n\n### Data Structures\n\n1. **Sets**\n   - Unordered collection of unique elements\n   - Fast membership testing: `O(1)` average case\n   - Use for removing duplicates, set operations (union, intersection)\n   - Example: `my_set = {1, 2, 3, 4}`\n\n2. **Dictionaries**\n   - Key-value pairs with `O(1)` average lookup\n   - Use for fast lookups, counting, grouping\n   - Example: `my_dict = {'key': 'value'}`\n\n3. **Tuples**\n   - Immutable ordered collections\n   - Faster than lists for fixed data\n   - Use for grouping related values\n   - Example: `my_tuple = (1, 2, 3, 4)`\n\n### Large Datasets and Memory Management\n\n1. **Use NumPy Arrays**\n   - More memory-efficient than Python lists\n   - Faster operations for numerical data\n   - Use `np.array()` instead of lists for large numerical datasets\n\n2. **Sample Data for Testing**\n   - Don't load entire dataset during development\n   - Use random sampling to test code quickly\n   - Load full dataset only when necessary\n\n3. **Lazy Loading**\n   - Load data only when needed\n   - Use generators for on-demand data processing\n   - Reduces initial memory footprint\n\n4. **Use Generators**\n   - Process one item at a time\n   - Perfect for datasets that don't fit in memory\n   - Use `yield` to create generator functions\n\n5. **Online Learning Algorithms**\n   - Use algorithms that process data in chunks\n   - Ideal for machine learning with large datasets\n   - Examples: SGD, online clustering\n\n6. **Efficient Data Storage**\n   - Use HDF5 or Parquet for large datasets\n   - Store data on disk, load only needed portions\n   - Better compression and faster I/O\n\n7. **Memory Profiling**\n   - Use `memory_profiler` or `psutil` to track memory usage\n   - Identify memory leaks early\n   - Optimize memory-intensive operations\n\n### String and Number Operations\n\n1. **String Formatting**\n   - Prefer f-strings: `f\"My name is {name}\"`\n   - Faster and more readable than `.format()` or `%` formatting\n   - Use `.format()` for complex formatting needs\n\n2. **Regular Expressions**\n   - Use `re` module for pattern matching\n   - Compile patterns with `re.compile()` for repeated use\n   - Useful for validation, parsing, search operations\n\n3. **String Methods**\n   - `.strip()` - remove whitespace\n   - `.split()` - split into list\n   - `.replace()` - replace substrings\n   - `.join()` - efficient string concatenation\n\n4. **Number Formatting**\n   - Use f-strings: `f\"{value:.2f}\"` for decimals\n   - Use `f\"{1000000:,}\"` for comma separators\n   - Use `decimal.Decimal` for financial calculations (not `float`)\n\n5. **Type Casting**\n   - `int(\"10\")` → 10\n   - `str(10)` → \"10\"\n   - `float(\"3.14\")` → 3.14\n   - Use appropriate types for operations\n\n6. **Math Operations**\n   - Use `math` module for standard math functions\n   - Use NumPy for complex operations and matrix math\n   - NumPy operations are vectorized and much faster\n\n### Debugging and Error Handling\n\n1. **Use pdb (Python Debugger)**\n   - Step through code line by line\n   - Set breakpoints with `breakpoint()` (Python 3.7+)\n   - Inspect variables and call stack\n\n2. **Add Print Statements**\n   - Simple debugging with `print()`\n   - Use for quick value inspection\n   - Remove or replace with logging in production\n\n3. **Use Linters**\n   - Check code for errors before running\n   - Use `pylint`, `flake8`, or `ruff`\n   - Catch issues early in development\n\n4. **Write Unit Tests**\n   - Test small parts of code separately\n   - Use `pytest` or `unittest`\n   - Catch bugs early with automated testing\n\n5. **Use Logging Instead of Print**\n   - Better for production code\n   - Configurable log levels (DEBUG, INFO, WARNING, ERROR)\n   - Can write to files, console, or external services\n\n6. **Try-Except Blocks**\n   - Catch and handle errors gracefully\n   - Prevent unexpected crashes\n   - Use specific exception types when possible\n\n7. **ExceptionGroup (Python 3.12+)**\n   - Group multiple errors together\n   - Handle multiple exceptions in one block\n   - Cleaner error handling for concurrent operations\n\n8. **Assert Statements**\n   - Quick condition checking\n   - Use for debugging and validation\n   - Can be disabled with `-O` flag in production\n\n9. **Traceback Module**\n   - Get detailed error information\n   - See exactly where errors occurred\n   - Useful for debugging complex issues\n\n### Code Quality Best Practices\n\n1. **Clear Naming**\n   - Use descriptive names for variables and functions\n   - Follow naming conventions (snake_case for variables/functions, CamelCase for classes)\n   - Names should explain purpose without comments\n\n2. **Proper Indentation and Spacing**\n   - Use 4 spaces for indentation (PEP 8)\n   - Keep lines under 80-100 characters\n   - Use blank lines to separate logical sections\n\n3. **Add Comments**\n   - Explain *why*, not *what*\n   - Use comments for non-obvious code\n   - Keep comments up-to-date with code changes\n\n4. **Keep Functions Small**\n   - Each function should do one thing well\n   - Easier to test, debug, and reuse\n   - Single Responsibility Principle\n\n5. **Avoid Global Variables**\n   - Pass data as function parameters\n   - Use classes to encapsulate state\n   - Makes code more testable and maintainable\n\n6. **Use Docstrings**\n   - Write function/class descriptions using triple quotes\n   - Follow PEP 257 conventions\n   - Include parameter and return value descriptions\n\n7. **Follow PEP 8**\n   - Python's official style guide\n   - Use tools like `black` or `autopep8` for formatting\n   - Consistent code style across projects\n\n8. **TaskGroups (Python 3.12+)**\n   - Safer alternative to managing async tasks manually\n   - Automatic cleanup and error handling\n   - Better than raw asyncio for grouped operations\n\n### Modules and Packages\n\n1. **Create Modules**\n   - Save functions/classes in `.py` files\n   - Example: `mymodule.py`\n\n2. **Import Modules**\n   - Use `import mymodule` to access all items\n   - Use `from mymodule import myfunction` for specific items\n\n3. **Create Packages**\n   - Make folder with `__init__.py` file\n   - Add `.py` files (modules) inside folder\n   - Example: `mypackage/__init__.py`, `mypackage/mymodule.py`\n\n4. **Import from Packages**\n   - Use `import mypackage.mymodule`\n   - Use `from mypackage import mymodule`\n   - Use `from mypackage.mymodule import myfunction`\n\n5. **Use __init__.py Smartly**\n   - Add shared functions/variables in `__init__.py`\n   - Makes them available across the package\n   - Can control package-level imports\n\n### Object-Oriented Programming\n\n1. **Create Classes**\n   - Use `class MyClass:` to define templates\n   - Classes encapsulate data and behavior\n\n2. **Create Objects**\n   - Objects are instances of classes\n   - Example: `my_object = MyClass()`\n\n3. **Use Attributes**\n   - Store data in objects\n   - Example: `self.name = \"John\"`\n\n4. **Use Methods**\n   - Functions inside classes that work with attributes\n   - Example: `def greet(self): print(self.name)`\n\n5. **Use Inheritance**\n   - Classes can inherit from other classes\n   - Example: `class Dog(Animal):`\n   - Reuse code and extend functionality\n\n6. **Use Polymorphism**\n   - Different classes can have same method names\n   - Python uses the right method based on object type\n   - Enables flexible, extensible code\n\n7. **Use Encapsulation**\n   - Hide internal details with single underscore: `_name`\n   - Signal that attribute is private-like\n   - Convention, not enforced (Python doesn't have true private)\n\n### Data Analysis Libraries\n\n1. **NumPy**\n   - Large arrays and matrices of numerical data\n   - Mathematical operations (linear algebra, Fourier transforms, statistics)\n   - Foundation for scientific computing\n\n2. **Pandas**\n   - Tabular data manipulation (CSV, Excel, SQL)\n   - DataFrames and Series for data analysis\n   - Reading/writing various file formats\n\n3. **Matplotlib**\n   - Static, animated, and interactive visualizations\n   - Wide range of plots (line, scatter, histogram, heatmap)\n\n4. **Scikit-learn**\n   - Machine learning algorithms\n   - Classification, regression, clustering, dimensionality reduction\n   - Model selection, evaluation, preprocessing\n\n5. **Seaborn**\n   - High-level interface for statistical graphics\n   - Built on Matplotlib\n   - Beautiful and informative visualizations\n\n6. **SciPy**\n   - Algorithms for optimization, signal processing, image processing\n   - Interpolation, integration, and more\n   - Scientific computing beyond NumPy",
  "tags": [
    "python",
    "coding-standards",
    "pep8",
    "flask",
    "performance-optimization",
    "best-practices",
    "automation",
    "type-hints",
    "code-organization",
    "debugging"
  ],
  "files": [
    ".cursor/rules/python-style.mdc"
  ],
  "related": [
    "Flask application factories",
    "Blueprints for route organization",
    "pyautogui and pytesseract for automation",
    "PEP 8 style guidelines",
    "Type hints and function annotations",
    "NumPy and SciPy for scientific computing",
    "Performance optimization patterns",
    "Error handling with early returns and guard clauses"
  ],
  "context": "This knowledge represents the comprehensive Python coding standards and best practices for Matthew's development environment. It covers general Python standards, Flask-specific patterns, automation scripts, performance optimization, advanced features, data structures, memory management, debugging, and code quality practices. These rules are applied contextually when working with Python files (*.py), requirements.txt, and setup.py files.",
  "rationale": "These Python rules ensure consistent code style, performance optimization, and best practices across all Python projects. They emphasize functional programming patterns, Flask application structure, automation patterns with pyautogui/pytesseract, and comprehensive performance optimization strategies. The rules are designed to help AI agents write Python code that follows Matthew's preferred patterns and standards.",
  "examples": [
    "Flask Blueprint pattern: `blueprints/user_routes.py`",
    "List comprehension: `[x**2 for x in range(10)]`",
    "F-string formatting: `f\"My name is {name}\"`",
    "Type hints: `def process_data(data: list[str]) -> dict[str, int]:`",
    "Context manager: `with open('file.txt') as f:`",
    "Early return pattern: `if not user: return None`"
  ]
}
