/**
 * @name Dungeons
 * @author BlueFlashX1
 * @description Solo Leveling Dungeon system - Random dungeons spawn in channels, fight mobs and bosses with your stats and shadow army
 * @version 2.0.0
 *
 * Features:
 * - Random dungeon spawns per message (10% chance)
 * - One dungeon per channel (across all servers)
 * - User can select which dungeon to participate in
 * - Shadow army attacks ALL dungeons simultaneously
 * - Shadows can die and be revived with mana
 * - Boss HP bars, user HP/Mana bars
 * - Continuous mob spawning
 * - IndexedDB storage for dungeon persistence
 * - Visual dungeon indicators and selection UI
 */

/**
 * DungeonStorageManager - IndexedDB storage manager for Dungeons plugin
 */
class DungeonStorageManager {
  constructor(userId) {
    this.userId = userId || 'default';
    this.dbName = `DungeonsDB_${this.userId}`;
    this.dbVersion = 1;
    this.storeName = 'dungeons';
    this.db = null;
  }

  async init() {
    return new Promise((resolve, reject) => {
      if (!window.indexedDB) {
        reject(new Error('IndexedDB not supported'));
        return;
      }

      const request = indexedDB.open(this.dbName, this.dbVersion);

      request.onerror = () => reject(request.error);
      request.onsuccess = () => {
        this.db = request.result;
        resolve(this.db);
      };

      request.onupgradeneeded = (event) => {
        const db = event.target.result;
        if (!db.objectStoreNames.contains(this.storeName)) {
          const objectStore = db.createObjectStore(this.storeName, { keyPath: 'id' });
          objectStore.createIndex('channelKey', 'channelKey', { unique: true });
          objectStore.createIndex('guildId', 'guildId', { unique: false });
          objectStore.createIndex('channelId', 'channelId', { unique: false });
          objectStore.createIndex('rank', 'rank', { unique: false });
          objectStore.createIndex('startTime', 'startTime', { unique: false });
        }
      };

      request.onblocked = () => {
        console.warn('DungeonStorageManager: Database upgrade blocked by other tabs');
        reject(new Error('Database upgrade blocked'));
      };
    });
  }

  async saveDungeon(dungeon) {
    if (!this.db) await this.init();
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction([this.storeName], 'readwrite');
      const store = transaction.objectStore(this.storeName);
      const request = store.put(dungeon);
      request.onsuccess = () => resolve({ success: true });
      request.onerror = () => reject(request.error);
    });
  }

  async getDungeon(channelKey) {
    if (!this.db) await this.init();
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction([this.storeName], 'readonly');
      const store = transaction.objectStore(this.storeName);
      const index = store.index('channelKey');
      const request = index.get(channelKey);
      request.onsuccess = () => resolve(request.result || null);
      request.onerror = () => reject(request.error);
    });
  }

  async getAllDungeons() {
    if (!this.db) await this.init();
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction([this.storeName], 'readonly');
      const store = transaction.objectStore(this.storeName);
      const request = store.getAll();
      request.onsuccess = () => resolve(request.result || []);
      request.onerror = () => reject(request.error);
    });
  }

  async deleteDungeon(channelKey) {
    if (!this.db) await this.init();
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction([this.storeName], 'readwrite');
      const store = transaction.objectStore(this.storeName);
      const index = store.index('channelKey');
      const request = index.getKey(channelKey);
      request.onsuccess = () => {
        const key = request.result;
        if (key) {
          const deleteRequest = store.delete(key);
          deleteRequest.onsuccess = () => resolve({ success: true });
          deleteRequest.onerror = () => reject(deleteRequest.error);
        } else {
          resolve({ success: false, reason: 'Not found' });
        }
      };
      request.onerror = () => reject(request.error);
    });
  }

  async clearCompletedDungeons() {
    if (!this.db) await this.init();
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction([this.storeName], 'readwrite');
      const store = transaction.objectStore(this.storeName);
      const request = store.openCursor();
      let deleted = 0;

      request.onsuccess = (event) => {
        const cursor = event.target.result;
        if (cursor) {
          const dungeon = cursor.value;
          if (dungeon.completed || dungeon.failed) {
            cursor.delete();
            deleted++;
          }
          cursor.continue();
        } else {
          resolve({ deleted });
        }
      };
      request.onerror = () => reject(request.error);
    });
  }
}

module.exports = class Dungeons {
  constructor() {
    this.defaultSettings = {
      enabled: true,
      spawnChance: 10, // 10% chance per message
      dungeonDuration: 600000, // 10 minutes
      shadowAttackInterval: 3000,
      userAttackCooldown: 2000,
      mobKillNotificationInterval: 30000,
      mobSpawnInterval: 5000, // Spawn new mobs every 5 seconds
      mobSpawnCount: 2, // Spawn 2 mobs at a time
      shadowReviveCost: 50, // Mana cost to revive a shadow
      // Dungeon ranks including SS, SSS
      dungeonRanks: ['E', 'D', 'C', 'B', 'A', 'S', 'SS', 'SSS', 'Monarch'],
      userActiveDungeon: null,
      lastSpawnTime: {},
      mobKillNotifications: {},
      // User HP/Mana (calculated from stats)
      userHP: null, // Will be calculated from vitality
      userMaxHP: null,
      userMana: null, // Will be calculated from intelligence
      userMaxMana: null,
    };

    this.settings = this.defaultSettings;
    this.messageObserver = null;
    this.shadowAttackIntervals = new Map();
    this.mobKillNotificationTimers = new Map();
    this.mobSpawnTimers = new Map();
    this.bossAttackTimers = new Map(); // Boss attack timers per dungeon
    this.mobAttackTimers = new Map(); // Mob attack timers per dungeon
    this.dungeonIndicators = new Map();
    this.bossHPBars = new Map();
    this.userHPBar = null;
    this.dungeonButton = null;
    this.dungeonModal = null;
    this.toolbarCheckInterval = null;
    this._dungeonButtonRetryCount = 0;
    this.lastUserAttackTime = 0;
    this.storageManager = null;
    this.activeDungeons = new Map(); // Use Map for better performance
    this.panelWatcher = null; // Watch for panel DOM changes
    this.hiddenComments = new Map(); // Track hidden comment elements per channel

    // Plugin references
    this.soloLevelingStats = null;
    this.shadowArmy = null;
    this.toasts = null;
    this.deadShadows = new Map(); // Track dead shadows per dungeon
    this.dungeonCleanupInterval = null;

    // Fallback toast system
    this.fallbackToastContainer = null;
    this.fallbackToasts = [];

    // Track observer start time to ignore old messages
    this.observerStartTime = Date.now();
    this.processedMessageIds = new Set(); // Track processed message IDs to avoid duplicates
  }

  async start() {
    // Reset observer start time when plugin starts
    this.observerStartTime = Date.now();
    console.log('[Dungeons] üöÄ Plugin starting...');
    this.loadSettings();
    console.log('[Dungeons] Settings loaded', {
      enabled: this.settings.enabled,
      spawnChance: this.settings.spawnChance,
      dungeonDuration: this.settings.dungeonDuration,
    });
    this.injectCSS();
    this.loadPluginReferences();
    await this.initStorage();
    console.log('[Dungeons] Storage initialized');

    // Retry loading plugin references (especially for toasts plugin)
    setTimeout(() => {
      if (!this.toasts) {
        console.log('[Dungeons] Retrying plugin references load (toasts plugin)...');
        this.loadPluginReferences();
      }
    }, 1000);

    setTimeout(() => {
      if (!this.toasts) {
        console.log('[Dungeons] Final retry for plugin references load...');
        this.loadPluginReferences();
      }
    }, 3000);

    // Create button with retry logic
    this.createDungeonButton();

    // Also retry button creation after delays to ensure Discord UI is ready
    setTimeout(() => {
      if (!this.dungeonButton || !document.body.contains(this.dungeonButton)) {
        console.log('[Dungeons] Retrying dungeon button creation...');
        this.createDungeonButton();
      }
    }, 2000);

    // Additional retry after longer delay (for plugin re-enabling)
    setTimeout(() => {
      if (!this.dungeonButton || !document.body.contains(this.dungeonButton)) {
        console.log('[Dungeons] Final retry for dungeon button creation...');
        this.createDungeonButton();
      }
    }, 5000);

    // #region agent log
    fetch('http://127.0.0.1:7242/ingest/b030fef3-bf2c-4bcb-b879-fe51f8a5dfa0', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        location: 'Dungeons.plugin.js:249',
        message: 'About to start message observer',
        data: { documentReady: document.readyState, bodyExists: !!document.body },
        timestamp: Date.now(),
        sessionId: 'debug-session',
        runId: 'run1',
        hypothesisId: 'A',
      }),
    }).catch(() => {});
    // #endregion
    this.startMessageObserver();
    this.startDungeonCleanupLoop();
    await this.restoreActiveDungeons();
    console.log('[Dungeons] Active dungeons restored', {
      count: this.activeDungeons.size,
    });
    this.setupChannelWatcher();
    console.log('[Dungeons] ‚úÖ Plugin started successfully');
  }

  stop() {
    this.stopMessageObserver();
    this.stopAllShadowAttacks();
    this.stopAllBossAttacks();
    this.stopAllMobAttacks();
    this.stopAllDungeonCleanup();
    this.removeAllIndicators();
    this.removeAllBossHPBars();

    // Clean up fallback toast container
    if (this.fallbackToastContainer && this.fallbackToastContainer.parentNode) {
      this.fallbackToastContainer.parentNode.removeChild(this.fallbackToastContainer);
      this.fallbackToastContainer = null;
    }
    this.fallbackToasts = [];
    // Restore all hidden comments
    this.hiddenComments.forEach((_, channelKey) => {
      this.showChannelHeaderComments(channelKey);
    });
    this.hiddenComments.clear();
    this.removeUserHPBar();
    this.removeDungeonButton();
    this.closeDungeonModal();
    this.stopPanelWatcher();
    this.stopChannelWatcher();
    this.saveSettings();

    // Remove popstate listener
    if (this._popstateHandler) {
      window.removeEventListener('popstate', this._popstateHandler);
      this._popstateHandler = null;
    }

    // Remove statsChanged listener to prevent memory leak
    if (this._onStatsChangedUnsubscribe && typeof this._onStatsChangedUnsubscribe === 'function') {
      this._onStatsChangedUnsubscribe();
      this._onStatsChangedUnsubscribe = null;
    }

    console.log('Dungeons plugin stopped');
  }

  async initStorage() {
    try {
      const userId = await this.getUserId();
      this.storageManager = new DungeonStorageManager(userId);
      await this.storageManager.init();
    } catch (error) {
      console.error('Dungeons: Failed to initialize storage', error);
    }
  }

  async getUserId() {
    try {
      if (window.Discord && window.Discord.user && window.Discord.user.id) {
        return window.Discord.user.id;
      }
      const UserStore =
        BdApi.Webpack?.getStore?.('UserStore') ||
        BdApi.Webpack?.getModule?.((m) => m?.getCurrentUser);
      if (UserStore && UserStore.getCurrentUser) {
        const user = UserStore.getCurrentUser();
        if (user && user.id) return user.id;
      }
    } catch (error) {
      console.warn('Dungeons: Failed to get user ID', error);
    }
    return 'default';
  }

  loadSettings() {
    try {
      const saved = BdApi.Data.load('Dungeons', 'settings');
      if (saved) {
        this.settings = { ...this.defaultSettings, ...saved };
        // Initialize user HP/Mana from stats if not set
        this.initializeUserStats();
      } else {
        this.initializeUserStats();
      }
    } catch (error) {
      console.error('Dungeons: Failed to load settings', error);
      this.settings = { ...this.defaultSettings };
    }
  }

  saveSettings() {
    try {
      BdApi.Data.save('Dungeons', 'settings', this.settings);
    } catch (error) {
      console.error('Dungeons: Failed to save settings', error);
    }
  }

  initializeUserStats() {
    // Calculate user HP from TOTAL EFFECTIVE VITALITY (including buffs)
    if (!this.settings.userMaxHP || this.settings.userMaxHP === null) {
      const totalStats =
        this.soloLevelingStats?.getTotalEffectiveStats?.() ||
        this.soloLevelingStats?.settings?.stats ||
        {};
      const vitality = totalStats.vitality || 0;
      this.settings.userMaxHP = this.calculateHP(
        vitality,
        this.soloLevelingStats?.settings?.rank || 'E'
      );
      if (!this.settings.userHP || this.settings.userHP === null) {
        this.settings.userHP = this.settings.userMaxHP;
      }
    }

    // Calculate user mana from TOTAL EFFECTIVE INTELLIGENCE (including buffs)
    if (!this.settings.userMaxMana || this.settings.userMaxMana === null) {
      const totalStats =
        this.soloLevelingStats?.getTotalEffectiveStats?.() ||
        this.soloLevelingStats?.settings?.stats ||
        {};
      const intelligence = totalStats.intelligence || 0;
      this.settings.userMaxMana = 100 + intelligence * 10;
      if (!this.settings.userMana || this.settings.userMana === null) {
        this.settings.userMana = this.settings.userMaxMana;
      }
    }
  }

  loadPluginReferences() {
    try {
      // Load SoloLevelingStats plugin
      const soloPlugin = BdApi.Plugins.get('SoloLevelingStats');
      if (soloPlugin?.instance) {
        this.soloLevelingStats = soloPlugin.instance;
        console.log('[Dungeons] ‚úì SoloLevelingStats plugin loaded');
        // Initialize user stats after loading plugin reference
        this.initializeUserStats();

        // Subscribe to stats changes to update HP/Mana bars
        if (typeof this.soloLevelingStats.on === 'function') {
          const callback = () => {
            this.updateUserHPBar();
          };
          this._onStatsChangedUnsubscribe = this.soloLevelingStats.on('statsChanged', callback);
        }
      } else {
        console.log('[Dungeons] ‚ö† SoloLevelingStats plugin not found');
      }

      // Load ShadowArmy plugin
      const shadowPlugin = BdApi.Plugins.get('ShadowArmy');
      if (shadowPlugin?.instance) {
        this.shadowArmy = shadowPlugin.instance;
        console.log('[Dungeons] ‚úì ShadowArmy plugin loaded');
      } else {
        console.log('[Dungeons] ‚ö† ShadowArmy plugin not found');
      }

      // Load SoloLevelingToasts plugin (with detailed checking)
      const toastsPlugin = BdApi.Plugins.get('SoloLevelingToasts');
      if (toastsPlugin) {
        if (toastsPlugin.instance) {
          // Check if the instance has the showToast method
          if (typeof toastsPlugin.instance.showToast === 'function') {
            this.toasts = toastsPlugin.instance;
            console.log('[Dungeons] ‚úì SoloLevelingToasts plugin loaded successfully');
          } else {
            console.warn(
              '[Dungeons] ‚ö† SoloLevelingToasts plugin instance found but showToast method missing'
            );
          }
        } else {
          console.warn(
            `[Dungeons] ‚ö† SoloLevelingToasts plugin exists but instance not ready (enabled: ${toastsPlugin.enabled})`
          );
        }
      } else {
        console.warn(
          '[Dungeons] ‚ö† SoloLevelingToasts plugin not found - will use fallback notifications'
        );
      }
    } catch (error) {
      console.error('[Dungeons] Error loading plugin references:', error);
    }
  }

  // ============================================================================
  // CHANNEL DETECTION (IMPROVED)
  // ============================================================================
  /**
   * Get all text channels for a guild
   */
  getAllGuildChannels(guildId) {
    try {
      const ChannelStore =
        BdApi.Webpack?.getStore?.('ChannelStore') ||
        BdApi.Webpack?.getModule?.((m) => m?.getChannel);

      if (ChannelStore) {
        const allChannels = Object.values(ChannelStore.getChannels?.() || {});
        // Filter for text channels (type 0) in this guild
        const guildTextChannels = allChannels.filter(
          (channel) => channel.guild_id === guildId && channel.type === 0
        );
        return guildTextChannels;
      }
    } catch (e) {
      console.error('[Dungeons] Error getting guild channels:', e);
    }
    return [];
  }

  /**
   * Get a random channel from the current guild
   */
  getRandomGuildChannel() {
    try {
      const currentInfo = this.getChannelInfo();
      if (!currentInfo || !currentInfo.guildId) {
        console.log('[Dungeons] No current channel info for random selection');
        return null;
      }

      const channels = this.getAllGuildChannels(currentInfo.guildId);
      console.log('[Dungeons] getAllGuildChannels result', {
        guildId: currentInfo.guildId,
        channelCount: channels.length,
        channelNames: channels.map((c) => c.name),
        channelIds: channels.map((c) => c.id),
      });

      if (channels.length === 0) {
        console.log('[Dungeons] No channels found in guild');
        return null;
      }

      // Pick a random channel
      const randomIndex = Math.floor(Math.random() * channels.length);
      const randomChannel = channels[randomIndex];
      console.log('[Dungeons] Random channel selected', {
        index: randomIndex,
        totalChannels: channels.length,
        selectedChannel: {
          id: randomChannel.id,
          name: randomChannel.name,
        },
        currentChannel: {
          id: currentInfo.channelId,
          name: currentInfo.channelName,
        },
        isDifferent: randomChannel.id !== currentInfo.channelId,
      });

      return {
        guildId: currentInfo.guildId,
        channelId: randomChannel.id,
        channelName: randomChannel.name,
      };
    } catch (e) {
      console.error('[Dungeons] Error getting random channel:', e);
      return null;
    }
  }

  getChannelInfo() {
    try {
      // Method 1: URL parsing
      const pathMatch = window.location.pathname.match(/channels\/(\d+)\/(\d+)/);
      if (pathMatch) {
        return { guildId: pathMatch[1], channelId: pathMatch[2] };
      }

      // Method 2: Try BetterDiscord Webpack stores
      try {
        const ChannelStore =
          BdApi.Webpack?.getStore?.('ChannelStore') ||
          BdApi.Webpack?.getModule?.((m) => m?.getChannel);
        if (ChannelStore) {
          const selectedChannelId = ChannelStore.getChannelId?.();
          const selectedChannel = ChannelStore.getChannel?.(selectedChannelId);
          if (selectedChannel) {
            return {
              guildId: selectedChannel.guild_id || 'DM',
              channelId: selectedChannel.id,
            };
          }
        }

        const GuildStore =
          BdApi.Webpack?.getStore?.('GuildStore') || BdApi.Webpack?.getModule?.((m) => m?.getGuild);
        if (GuildStore && ChannelStore) {
          const selectedChannelId = ChannelStore.getChannelId?.();
          const selectedChannel = ChannelStore.getChannel?.(selectedChannelId);
          if (selectedChannel) {
            const guildId = selectedChannel.guild_id || 'DM';
            return { guildId, channelId: selectedChannel.id };
          }
        }
      } catch (e) {
        // Fall through to React fiber method
      }

      // Method 3: React fiber traversal
      const channelElement = document.querySelector('[class*="channel"]');
      if (channelElement) {
        const reactKey = Object.keys(channelElement).find(
          (key) => key.startsWith('__reactFiber') || key.startsWith('__reactInternalInstance')
        );
        if (reactKey) {
          let fiber = channelElement[reactKey];
          for (let i = 0; i < 20 && fiber; i++) {
            if (fiber.memoizedProps?.channel?.id) {
              return {
                guildId: fiber.memoizedProps.channel.guild_id || 'DM',
                channelId: fiber.memoizedProps.channel.id,
              };
            }
            fiber = fiber.return;
          }
        }
      }

      return null;
    } catch (error) {
      console.error('Dungeons: Error getting channel info', error);
      return null;
    }
  }

  // ============================================================================
  // DUNGEON NAMES GENERATOR
  // ============================================================================
  generateDungeonName(rank) {
    const prefixes = [
      'Ancient',
      'Forgotten',
      'Cursed',
      'Dark',
      'Shadow',
      'Abyssal',
      'Infernal',
      'Eternal',
    ];
    const suffixes = [
      'Labyrinth',
      'Catacombs',
      'Ruins',
      'Temple',
      'Sanctuary',
      'Fortress',
      'Tower',
      'Dungeon',
    ];
    const prefix = prefixes[Math.floor(Math.random() * prefixes.length)];
    const suffix = suffixes[Math.floor(Math.random() * suffixes.length)];
    return `${prefix} ${suffix} of ${rank}-Rank`;
  }

  generateBossName(rank) {
    const titles = ['Lord', 'King', 'Tyrant', 'Overlord', 'Destroyer', 'Conqueror', 'Dominator'];
    const names = ['Malice', 'Despair', 'Ruin', 'Doom', 'Chaos', 'Void', 'Shadow'];
    const title = titles[Math.floor(Math.random() * titles.length)];
    const name = names[Math.floor(Math.random() * names.length)];
    return `${title} ${name}`;
  }

  // ============================================================================
  // MESSAGE OBSERVER
  // ============================================================================
  startMessageObserver() {
    // #region agent log
    fetch('http://127.0.0.1:7242/ingest/b030fef3-bf2c-4bcb-b879-fe51f8a5dfa0', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        location: 'Dungeons.plugin.js:550',
        message: 'startMessageObserver called',
        data: { hasObserver: !!this.messageObserver, documentReady: document.readyState },
        timestamp: Date.now(),
        sessionId: 'debug-session',
        runId: 'run1',
        hypothesisId: 'A',
      }),
    }).catch(() => {});
    // #endregion

    if (this.messageObserver) {
      console.log('[Dungeons] Message observer already exists');
      // #region agent log
      fetch('http://127.0.0.1:7242/ingest/b030fef3-bf2c-4bcb-b879-fe51f8a5dfa0', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          location: 'Dungeons.plugin.js:553',
          message: 'Observer already exists, returning early',
          data: {},
          timestamp: Date.now(),
          sessionId: 'debug-session',
          runId: 'run1',
          hypothesisId: 'A',
        }),
      }).catch(() => {});
      // #endregion
      return;
    }

    console.log('[Dungeons] üéØ Starting message observer...');


    this.messageObserver = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        mutation.addedNodes.forEach((node) => {
          // Skip text nodes and non-element nodes
          if (node.nodeType !== 1) return;

          // Try multiple strategies to find message element:
          // 1. Check if node or its descendants contain a message element (most reliable)
          // 2. Check for data-list-item-id (Discord's message identifier)
          // 3. Check if node itself is a message container
          // 4. Check parent/ancestor for message container
          // 5. Look for author/username elements (indicates message container)
          let messageElement = null;

          // Strategy 0: Check if node or its descendants contain a message element (like CriticalHit does)
          const messageInNode = node.querySelector?.('[class*="message"]');
          if (messageInNode) {
            messageElement = messageInNode;
            // #region agent log
            fetch('http://127.0.0.1:7242/ingest/b030fef3-bf2c-4bcb-b879-fe51f8a5dfa0', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                location: 'Dungeons.plugin.js:695',
                message: 'Strategy 0 SUCCESS: Found message via querySelector in node',
                data: {
                  nodeClassName: node.className,
                  messageElementClassName: messageElement?.className,
                },
                timestamp: Date.now(),
                sessionId: 'debug-session',
                runId: 'run3',
                hypothesisId: 'C',
              }),
            }).catch(() => {});
            // #endregion
          }

          // Also check if node itself is a message element
          if (
            !messageElement &&
            (node.classList?.contains('message') ||
              (typeof node.className === 'string' && node.className.includes('message')))
          ) {
            messageElement = node;
            // #region agent log
            fetch('http://127.0.0.1:7242/ingest/b030fef3-bf2c-4bcb-b879-fe51f8a5dfa0', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                location: 'Dungeons.plugin.js:710',
                message: 'Strategy 0 SUCCESS: Node itself is a message element',
                data: { nodeClassName: node.className },
                timestamp: Date.now(),
                sessionId: 'debug-session',
                runId: 'run3',
                hypothesisId: 'C',
              }),
            }).catch(() => {});
            // #endregion
          }

          // Strategy 1: Check for data-list-item-id (most reliable Discord message identifier)
          const listItemId =
            node.getAttribute?.('data-list-item-id') ||
            node.closest?.('[data-list-item-id]')?.getAttribute('data-list-item-id');

          // #region agent log
          const hasListItemId = !!listItemId;
          const listItemIdValue = listItemId || null;
          const listItemIdStartsWithChat = listItemId?.startsWith('chat-messages') || false;
          fetch('http://127.0.0.1:7242/ingest/b030fef3-bf2c-4bcb-b879-fe51f8a5dfa0', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              location: 'Dungeons.plugin.js:704',
              message: 'Strategy 1: Checking data-list-item-id',
              data: {
                hasListItemId,
                listItemIdValue,
                listItemIdStartsWithChat,
                nodeClassName: node.className,
              },
              timestamp: Date.now(),
              sessionId: 'debug-session',
              runId: 'run3',
              hypothesisId: 'C',
            }),
          }).catch(() => {});
          // #endregion

          if (listItemId && listItemId.startsWith('chat-messages')) {
            messageElement = node.closest?.('[data-list-item-id]') || node;
            // #region agent log
            fetch('http://127.0.0.1:7242/ingest/b030fef3-bf2c-4bcb-b879-fe51f8a5dfa0', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                location: 'Dungeons.plugin.js:715',
                message: 'Strategy 1 SUCCESS: Found message via data-list-item-id',
                data: { listItemId, hasMessageElement: !!messageElement },
                timestamp: Date.now(),
                sessionId: 'debug-session',
                runId: 'run3',
                hypothesisId: 'C',
              }),
            }).catch(() => {});
            // #endregion
          }

          // Strategy 2: Check if node has message-related classes
          if (!messageElement) {
            const queryMessage = node.querySelector?.('[class*="message"]');
            const queryMessageContent = node.querySelector?.('[class*="messageContent"]');
            const queryMessageGroup = node.querySelector?.('[class*="messageGroup"]');
            const hasMessageClass = node.classList?.contains('message');
            const hasMessageContentClass = node.classList?.contains('messageContent');

            messageElement =
              queryMessage ||
              queryMessageContent ||
              queryMessageGroup ||
              (hasMessageClass ? node : null) ||
              (hasMessageContentClass ? node : null);

            // #region agent log
            fetch('http://127.0.0.1:7242/ingest/b030fef3-bf2c-4bcb-b879-fe51f8a5dfa0', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                location: 'Dungeons.plugin.js:735',
                message: 'Strategy 2: Checking message classes',
                data: {
                  queryMessage: !!queryMessage,
                  queryMessageContent: !!queryMessageContent,
                  queryMessageGroup: !!queryMessageGroup,
                  hasMessageClass,
                  hasMessageContentClass,
                  found: !!messageElement,
                },
                timestamp: Date.now(),
                sessionId: 'debug-session',
                runId: 'run3',
                hypothesisId: 'C',
              }),
            }).catch(() => {});
            // #endregion
          }

          // Strategy 3: Check parent chain for message container (with author element)
          if (!messageElement && node.parentElement) {
            const closestWithAuthor = node.parentElement.closest?.('[class*="author"]');
            const closestWithUsername = node.parentElement.closest?.('[class*="username"]');
            const closestWithListItemId = node.parentElement.closest?.('[data-list-item-id]');

            const parentWithAuthor =
              closestWithAuthor?.closest?.('[class*="message"]') ||
              closestWithUsername?.closest?.('[class*="message"]') ||
              closestWithListItemId;

            if (parentWithAuthor) {
              messageElement = parentWithAuthor;
            }

            // #region agent log
            fetch('http://127.0.0.1:7242/ingest/b030fef3-bf2c-4bcb-b879-fe51f8a5dfa0', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                location: 'Dungeons.plugin.js:760',
                message: 'Strategy 3: Checking parent chain',
                data: {
                  hasParent: !!node.parentElement,
                  closestWithAuthor: !!closestWithAuthor,
                  closestWithUsername: !!closestWithUsername,
                  closestWithListItemId: !!closestWithListItemId,
                  parentWithAuthor: !!parentWithAuthor,
                  found: !!messageElement,
                },
                timestamp: Date.now(),
                sessionId: 'debug-session',
                runId: 'run3',
                hypothesisId: 'C',
              }),
            }).catch(() => {});
            // #endregion
          }

          // Strategy 4: Fallback - check if any ancestor has author/username (indicates message)
          if (!messageElement && node.parentElement) {
            const ancestorWithAuthor =
              node.parentElement.closest?.('[class*="author"]')?.parentElement;
            const ancestorWithUsername =
              node.parentElement.closest?.('[class*="username"]')?.parentElement;
            const hasAuthorInAncestor =
              ancestorWithAuthor && ancestorWithAuthor.querySelector?.('[class*="author"]');

            if (hasAuthorInAncestor) {
              messageElement = ancestorWithAuthor;
            }

            // #region agent log
            fetch('http://127.0.0.1:7242/ingest/b030fef3-bf2c-4bcb-b879-fe51f8a5dfa0', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                location: 'Dungeons.plugin.js:780',
                message: 'Strategy 4: Checking ancestor chain',
                data: {
                  ancestorWithAuthor: !!ancestorWithAuthor,
                  ancestorWithUsername: !!ancestorWithUsername,
                  hasAuthorInAncestor,
                  found: !!messageElement,
                },
                timestamp: Date.now(),
                sessionId: 'debug-session',
                runId: 'run3',
                hypothesisId: 'C',
              }),
            }).catch(() => {});
            // #endregion
          }

          // #region agent log
          // Check parent chain to find message structure
          let parentChain = [];
          let current = node.parentElement;
          let depth = 0;
          while (current && depth < 5) {
            parentChain.push({
              tagName: current.tagName,
              className: current.className,
              id: current.id,
            });
            current = current.parentElement;
            depth++;
          }

          // Try to find message element in parent chain
          const messageInChain = parentChain.find(
            (p) => p.className?.includes('message') || p.className?.includes('Message')
          );

          fetch('http://127.0.0.1:7242/ingest/b030fef3-bf2c-4bcb-b879-fe51f8a5dfa0', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              location: 'Dungeons.plugin.js:600',
              message: 'Checking for message element',
              data: {
                hasMessageElement: !!messageElement,
                querySelectorResult: !!node.querySelector?.('[class*="message"]'),
                hasMessageClass: node.classList?.contains('message'),
                nodeClassName: node.className,
                nodeTagName: node.tagName,
                parentExists: !!node.parentElement,
                parentClassName: node.parentElement?.className,
                parentChain: parentChain,
                messageInChain: !!messageInChain,
                nodeTextContent: node.textContent?.substring(0, 100),
              },
              timestamp: Date.now(),
              sessionId: 'debug-session',
              runId: 'run3',
              hypothesisId: 'C',
            }),
          }).catch(() => {});
          // #endregion

          if (messageElement) {
            console.log('[Dungeons] üì® Message detected, calling handleMessage');
            // #region agent log
            fetch('http://127.0.0.1:7242/ingest/b030fef3-bf2c-4bcb-b879-fe51f8a5dfa0', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                location: 'Dungeons.plugin.js:625',
                message: 'Message detected in observer',
                data: {
                  nodeType: node.nodeType,
                  hasMessageElement: !!messageElement,
                  messageElementClassName: messageElement?.className,
                },
                timestamp: Date.now(),
                sessionId: 'debug-session',
                runId: 'run2',
                hypothesisId: 'C',
              }),
            }).catch(() => {});
            // #endregion
            this.handleMessage(messageElement);
          } else {
            // #region agent log
            fetch('http://127.0.0.1:7242/ingest/b030fef3-bf2c-4bcb-b879-fe51f8a5dfa0', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                location: 'Dungeons.plugin.js:640',
                message: 'Message element not found in node',
                data: {
                  nodeClassName: node.className,
                  nodeTagName: node.tagName,
                  nodeTextContent: node.textContent?.substring(0, 50),
                },
                timestamp: Date.now(),
                sessionId: 'debug-session',
                runId: 'run2',
                hypothesisId: 'C',
              }),
            }).catch(() => {});
            // #endregion
          }
        });
      });
    });

    // Find message container - use document.body as fallback to catch all DOM changes
    const findMessageContainer = () => {
      // Try specific message container selectors first
      const selectors = [
        '[class*="messagesWrapper"]',
        '[class*="chat"]',
        '[class*="messages"]',
        '[class*="messageList"]',
      ];

      for (const selector of selectors) {
        const container = document.querySelector(selector);
        if (container) {
          console.log('[Dungeons] Found container with selector:', selector, container.className);
          return container;
        }
      }

      // Fallback: Find scroller that contains actual message elements
      const scrollers = document.querySelectorAll('[class*="scroller"]');
      for (const scroller of scrollers) {
        const hasMessages = scroller.querySelector('[class*="message"]') !== null;
        if (hasMessages) {
          console.log('[Dungeons] Found scroller with messages:', scroller.className);
          return scroller;
        }
      }

      // Last resort: Use document.body to catch all DOM changes
      console.log('[Dungeons] Using document.body as fallback container');
      return document.body;
    };

    const messageContainer = findMessageContainer();

    // #region agent log
    fetch('http://127.0.0.1:7242/ingest/b030fef3-bf2c-4bcb-b879-fe51f8a5dfa0', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        location: 'Dungeons.plugin.js:585',
        message: 'Final container check',
        data: {
          found: !!messageContainer,
          className: messageContainer?.className,
          tagName: messageContainer?.tagName,
          id: messageContainer?.id,
        },
        timestamp: Date.now(),
        sessionId: 'debug-session',
        runId: 'run1',
        hypothesisId: 'B',
      }),
    }).catch(() => {});
    // #endregion

    console.log('[Dungeons] Message container check', {
      found: !!messageContainer,
      selector: messageContainer ? messageContainer.className : 'not found',
    });

    if (messageContainer) {
      this.messageObserver.observe(messageContainer, { childList: true, subtree: true });
      console.log('[Dungeons] ‚úÖ Message observer started successfully');
      // #region agent log
      fetch('http://127.0.0.1:7242/ingest/b030fef3-bf2c-4bcb-b879-fe51f8a5dfa0', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          location: 'Dungeons.plugin.js:592',
          message: 'Observer started successfully',
          data: { containerClassName: messageContainer.className },
          timestamp: Date.now(),
          sessionId: 'debug-session',
          runId: 'run1',
          hypothesisId: 'B',
        }),
      }).catch(() => {});
      // #endregion
    } else {
      console.error('[Dungeons] ‚ùå Message container not found! Observer not started.');
      // #region agent log
      fetch('http://127.0.0.1:7242/ingest/b030fef3-bf2c-4bcb-b879-fe51f8a5dfa0', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          location: 'Dungeons.plugin.js:595',
          message: 'Container not found - all selectors failed',
          data: { documentReady: document.readyState, bodyExists: !!document.body },
          timestamp: Date.now(),
          sessionId: 'debug-session',
          runId: 'run1',
          hypothesisId: 'A',
        }),
      }).catch(() => {});
      // #endregion

      // Retry after delay if container not found (timing issue)
      setTimeout(() => {
        // #region agent log
        fetch('http://127.0.0.1:7242/ingest/b030fef3-bf2c-4bcb-b879-fe51f8a5dfa0', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            location: 'Dungeons.plugin.js:600',
            message: 'Retrying container search after delay',
            data: {},
            timestamp: Date.now(),
            sessionId: 'debug-session',
            runId: 'run1',
            hypothesisId: 'A',
          }),
        }).catch(() => {});
        // #endregion
        if (!this.messageObserver) {
          this.startMessageObserver();
        }
      }, 2000);
    }
  }

  stopMessageObserver() {
    if (this.messageObserver) {
      this.messageObserver.disconnect();
      this.messageObserver = null;
    }
  }

  async handleMessage(messageElement) {
    console.log('[Dungeons] processMessageSent called', {
      enabled: this.settings.enabled,
      messageElement: !!messageElement,
    });

    if (!this.settings.enabled) {
      console.log('[Dungeons] ‚ùå Plugin disabled, skipping');
      return;
    }

    try {
      // Check if message is old (before observer started) - skip old messages
      const messageTimestamp = this.getMessageTimestamp(messageElement);
      if (messageTimestamp && messageTimestamp < this.observerStartTime) {
        console.log('[Dungeons] ‚è≠Ô∏è Skipping old message (before observer started)', {
          messageTime: new Date(messageTimestamp).toISOString(),
          observerStartTime: new Date(this.observerStartTime).toISOString(),
        });
        return;
      }

      // Check for duplicate processing using message ID
      const messageId = this.getMessageId(messageElement);
      if (messageId && this.processedMessageIds.has(messageId)) {
        console.log('[Dungeons] ‚è≠Ô∏è Skipping duplicate message', { messageId });
        return;
      }
      if (messageId) {
        this.processedMessageIds.add(messageId);
        // Limit set size to prevent memory leak
        if (this.processedMessageIds.size > 1000) {
          const firstId = this.processedMessageIds.values().next().value;
          this.processedMessageIds.delete(firstId);
        }
      }

      const isUserMsg = this.isUserMessage(messageElement);
      console.log('[Dungeons] Message check', { isUserMessage: isUserMsg });

      if (!isUserMsg) {
        console.log('[Dungeons] ‚ùå Not a user message, skipping');
        return;
      }

      const channelInfo = this.getChannelInfo();
      console.log('[Dungeons] Channel info', {
        channelInfo: channelInfo
          ? {
              guildId: channelInfo.guildId,
              channelId: channelInfo.channelId,
              channelName: channelInfo.channelName,
            }
          : null,
      });

      if (!channelInfo) {
        console.log('[Dungeons] ‚ùå No channel info, skipping');
        return;
      }

      // Get a random channel from the guild for dungeon spawn
      const randomChannelInfo = this.getRandomGuildChannel();
      if (randomChannelInfo) {
        const randomChannelKey = `${randomChannelInfo.guildId}_${randomChannelInfo.channelId}`;
        const currentChannelKey = `${channelInfo.guildId}_${channelInfo.channelId}`;
        console.log('[Dungeons] üé≤ Random channel selected for dungeon spawn', {
          currentChannel: { key: currentChannelKey, name: channelInfo.channelName },
          randomChannel: { key: randomChannelKey, name: randomChannelInfo.channelName },
          isDifferent: randomChannelKey !== currentChannelKey,
        });
        await this.checkDungeonSpawn(randomChannelKey, randomChannelInfo);
      } else {
        // Fallback to current channel if random selection fails
        const channelKey = `${channelInfo.guildId}_${channelInfo.channelId}`;
        console.log('[Dungeons] ‚ö†Ô∏è Fallback to current channel (random selection failed)', {
          channelKey,
        });
        await this.checkDungeonSpawn(channelKey, channelInfo);
      }

      // Still check current channel for user attacks
      const channelKey = `${channelInfo.guildId}_${channelInfo.channelId}`;
      if (this.settings.userActiveDungeon === channelKey) {
        const now = Date.now();
        if (now - this.lastUserAttackTime >= this.settings.userAttackCooldown) {
          await this.processUserAttack(channelKey);
          this.lastUserAttackTime = now;
        }
      }
    } catch (error) {
      console.error('Dungeons: Error handling message', error);
    }
  }

  /**
   * Get message timestamp from element
   */
  getMessageTimestamp(messageElement) {
    try {
      // Try to get timestamp from time element
      const timeElement = messageElement.querySelector('time');
      if (timeElement) {
        const datetime = timeElement.getAttribute('datetime');
        if (datetime) {
          return new Date(datetime).getTime();
        }
      }

      // Try to get from data attribute
      const timestamp = messageElement.getAttribute('data-timestamp');
      if (timestamp) {
        return parseInt(timestamp);
      }

      // Try React fiber
      const reactKey = Object.keys(messageElement).find(
        (key) => key.startsWith('__reactFiber') || key.startsWith('__reactInternalInstance')
      );
      if (reactKey) {
        let fiber = messageElement[reactKey];
        for (let i = 0; i < 20 && fiber; i++) {
          const timestamp = fiber.memoizedProps?.message?.timestamp;
          if (timestamp) {
            return new Date(timestamp).getTime();
          }
          fiber = fiber.return;
        }
      }
    } catch (e) {
      // Ignore errors
    }
    return null;
  }

  /**
   * Get message ID from element
   */
  getMessageId(messageElement) {
    try {
      // Try data-list-item-id
      const listItemId =
        messageElement.getAttribute('data-list-item-id') ||
        messageElement.closest('[data-list-item-id]')?.getAttribute('data-list-item-id');
      if (listItemId) return listItemId;

      // Try id attribute
      const id = messageElement.getAttribute('id');
      if (id) return id;

      // Try React fiber
      const reactKey = Object.keys(messageElement).find(
        (key) => key.startsWith('__reactFiber') || key.startsWith('__reactInternalInstance')
      );
      if (reactKey) {
        let fiber = messageElement[reactKey];
        for (let i = 0; i < 20 && fiber; i++) {
          const msgId = fiber.memoizedProps?.message?.id;
          if (msgId) return String(msgId);
          fiber = fiber.return;
        }
      }
    } catch (e) {
      // Ignore errors
    }
    return null;
  }

  isUserMessage(messageElement) {
    const authorElement =
      messageElement.querySelector('[class*="author"]') ||
      messageElement.querySelector('[class*="username"]') ||
      messageElement.querySelector('[class*="headerText"]');

    console.log('[Dungeons] isUserMessage check', {
      hasAuthorElement: !!authorElement,
      authorText: authorElement?.textContent?.substring(0, 50),
      messageClasses: messageElement.className,
    });

    if (!authorElement) {
      console.log('[Dungeons] No author element found, checking if message has content');
      // Fallback: Check if message has text content (might be a valid message without author element visible)
      const hasContent = messageElement.textContent && messageElement.textContent.trim().length > 0;
      if (hasContent) {
        console.log('[Dungeons] Message has content, accepting as user message');
        return true; // Accept messages with content even without author element
      }
      return false;
    }

    const botBadge =
      messageElement.querySelector('[class*="botTag"]') ||
      messageElement.querySelector('[class*="bot"]');

    const isBot = !!botBadge;
    console.log('[Dungeons] Bot check', { isBot, hasBotBadge: !!botBadge });

    return !botBadge;
  }

  // ============================================================================
  // DUNGEON SPAWNING
  // ============================================================================
  async checkDungeonSpawn(channelKey, channelInfo) {
    console.log('[Dungeons] checkDungeonSpawn called', {
      channelKey,
      enabled: this.settings.enabled,
      hasActiveDungeon: this.activeDungeons.has(channelKey),
      activeDungeonsCount: this.activeDungeons.size,
    });

    if (this.activeDungeons.has(channelKey)) {
      console.log('[Dungeons] ‚ùå Already has active dungeon, skipping spawn');
      return;
    }

    const lastSpawn = this.settings.lastSpawnTime[channelKey] || 0;
    const timeSinceLastSpawn = Date.now() - lastSpawn;
    const dungeonDuration = this.settings.dungeonDuration || 300000; // 5 minutes default
    const timeRemaining = dungeonDuration - timeSinceLastSpawn;

    console.log('[Dungeons] Spawn timing check', {
      lastSpawn: lastSpawn ? new Date(lastSpawn).toISOString() : 'never',
      timeSinceLastSpawn: `${Math.round(timeSinceLastSpawn / 1000)}s`,
      dungeonDuration: `${Math.round(dungeonDuration / 1000)}s`,
      timeRemaining: `${Math.round(timeRemaining / 1000)}s`,
      canSpawn: timeSinceLastSpawn >= dungeonDuration,
    });

    if (timeSinceLastSpawn < dungeonDuration) {
      console.log('[Dungeons] ‚ùå Too soon since last spawn, skipping', {
        timeRemaining: `${Math.round(timeRemaining / 1000)}s`,
      });
      return;
    }

    const spawnChance = this.settings.spawnChance || 10;
    const roll = Math.random() * 100;
    const spawnRolled = roll <= spawnChance;

    console.log('[Dungeons] Spawn chance roll', {
      spawnChance: `${spawnChance}%`,
      roll: `${roll.toFixed(2)}%`,
      spawnRolled,
    });

    if (!spawnRolled) {
      console.log('[Dungeons] ‚ùå Spawn chance roll failed, skipping');
      return;
    }

    console.log('[Dungeons] ‚úÖ All checks passed, creating dungeon...');
    const dungeonRank = this.calculateDungeonRank();
    console.log('[Dungeons] Calculated dungeon rank', { dungeonRank });
    await this.createDungeon(channelKey, channelInfo, dungeonRank);
  }

  calculateDungeonRank() {
    let userRank = 'E';
    if (this.soloLevelingStats?.settings) {
      userRank = this.soloLevelingStats.settings.rank || 'E';
    }
    const rankIndex = this.settings.dungeonRanks.indexOf(userRank);
    const maxRankIndex = this.settings.dungeonRanks.length - 1;
    const weights = [];
    for (let i = 0; i <= maxRankIndex; i++) {
      if (i <= rankIndex) {
        weights.push(10 - (rankIndex - i));
      } else {
        weights.push(Math.max(1, 5 - (i - rankIndex)));
      }
    }
    const totalWeight = weights.reduce((a, b) => a + b, 0);
    let random = Math.random() * totalWeight;
    for (let i = 0; i < weights.length; i++) {
      random -= weights[i];
      if (random <= 0) return this.settings.dungeonRanks[i];
    }
    return this.settings.dungeonRanks[0];
  }

  async createDungeon(channelKey, channelInfo, rank) {
    console.log('[Dungeons] üéØ createDungeon called', {
      channelKey,
      rank,
      channelInfo: channelInfo
        ? {
            guildId: channelInfo.guildId,
            channelId: channelInfo.channelId,
            channelName: channelInfo.channelName,
          }
        : null,
    });

    const rankIndex = this.settings.dungeonRanks.indexOf(rank);
    const baseBossHP = 500 + rankIndex * 500;
    const dungeonName = this.generateDungeonName(rank);
    const bossName = this.generateBossName(rank);

    console.log('[Dungeons] Dungeon details', {
      rankIndex,
      baseBossHP,
      dungeonName,
      bossName,
    });

    // Calculate boss stats based on rank
    const bossStrength = 50 + rankIndex * 25;
    const bossAgility = 30 + rankIndex * 15;
    const bossIntelligence = 40 + rankIndex * 20;
    const bossVitality = 60 + rankIndex * 30;

    const dungeon = {
      id: channelKey,
      channelKey,
      rank,
      name: dungeonName,
      mobs: {
        total: 0,
        remaining: 0,
        killed: 0,
        spawnRate: 2 + rankIndex,
        activeMobs: [], // Array of mob objects with HP and stats
      },
      boss: {
        name: bossName,
        hp: baseBossHP,
        maxHp: baseBossHP,
        rank,
        strength: bossStrength,
        agility: bossAgility,
        intelligence: bossIntelligence,
        vitality: bossVitality,
        lastAttackTime: 0,
        attackCooldown: 4000, // Boss attacks every 4 seconds
      },
      startTime: Date.now(),
      channelId: channelInfo.channelId,
      guildId: channelInfo.guildId,
      userParticipating: null,
      shadowAttacks: {},
      shadowContributions: {}, // Track XP contributions: { shadowId: { mobsKilled: 0, bossDamage: 0 } }
      shadowHP: {}, // Track shadow HP: { shadowId: { hp, maxHp } } - Object for serialization
      completed: false,
      failed: false,
    };

    this.activeDungeons.set(channelKey, dungeon);
    this.settings.lastSpawnTime[channelKey] = Date.now();
    this.settings.mobKillNotifications[channelKey] = { count: 0, lastNotification: Date.now() };

    console.log('[Dungeons] Dungeon object created', {
      activeDungeonsCount: this.activeDungeons.size,
      lastSpawnTime: new Date(this.settings.lastSpawnTime[channelKey]).toISOString(),
    });

    // Save to IndexedDB
    if (this.storageManager) {
      try {
        await this.storageManager.saveDungeon(dungeon);
        console.log('[Dungeons] ‚úÖ Dungeon saved to IndexedDB');
      } catch (error) {
        console.error('[Dungeons] ‚ùå Failed to save dungeon to IndexedDB', error);
      }
    } else {
      console.log('[Dungeons] ‚ö†Ô∏è No storage manager available');
    }

    this.saveSettings();
    console.log('[Dungeons] Settings saved');
    this.showDungeonIndicator(channelKey, channelInfo);
    console.log('[Dungeons] Dungeon indicator shown');
    this.showToast(`‚öîÔ∏è ${dungeonName} Spawned!`, 'info');
    console.log('[Dungeons] Toast notification shown');
    this.startShadowAttacks(channelKey);
    console.log('[Dungeons] Shadow attacks started');
    this.startMobKillNotifications(channelKey);
    console.log('[Dungeons] Mob kill notifications started');
    this.startMobSpawning(channelKey);
    console.log('[Dungeons] Mob spawning started');
    this.startBossAttacks(channelKey);
    console.log('[Dungeons] Boss attacks started');
    this.startMobAttacks(channelKey);
    console.log('[Dungeons] Mob attacks started');
    console.log(`[Dungeons] ‚úÖ Created ${rank}-rank dungeon: ${dungeonName}`, {
      dungeonId: dungeon.id,
      channelKey,
      activeDungeonsCount: this.activeDungeons.size,
    });
  }

  // ============================================================================
  // CONTINUOUS MOB SPAWNING
  // ============================================================================
  startMobSpawning(channelKey) {
    if (this.mobSpawnTimers.has(channelKey)) return;
    const timer = setInterval(() => {
      this.spawnMobs(channelKey);
    }, this.settings.mobSpawnInterval);
    this.mobSpawnTimers.set(channelKey, timer);
  }

  stopMobSpawning(channelKey) {
    const timer = this.mobSpawnTimers.get(channelKey);
    if (timer) {
      clearInterval(timer);
      this.mobSpawnTimers.delete(channelKey);
    }
  }

  stopAllMobSpawning() {
    this.mobSpawnTimers.forEach((timer) => clearInterval(timer));
    this.mobSpawnTimers.clear();
  }

  spawnMobs(channelKey) {
    const dungeon = this.activeDungeons.get(channelKey);
    if (!dungeon || dungeon.completed || dungeon.failed) {
      this.stopMobSpawning(channelKey);
      return;
    }

    // Only spawn mobs if boss is still alive
    if (dungeon.boss.hp > 0) {
      const spawnCount = this.settings.mobSpawnCount;
      const rankIndex = this.settings.dungeonRanks.indexOf(dungeon.rank);

      // Create mobs with HP and stats
      for (let i = 0; i < spawnCount; i++) {
        const mobStrength = 20 + rankIndex * 10;
        const mobAgility = 15 + rankIndex * 8;
        const mobIntelligence = 10 + rankIndex * 5;
        const mobVitality = 30 + rankIndex * 15;
        const mobHP = 50 + mobVitality * 2; // HP = base + vitality * 2

        const mob = {
          id: `mob_${Date.now()}_${Math.random()}`,
          hp: mobHP,
          maxHp: mobHP,
          strength: mobStrength,
          agility: mobAgility,
          intelligence: mobIntelligence,
          vitality: mobVitality,
          rank: dungeon.rank,
          lastAttackTime: 0,
          attackCooldown: 3000, // Mobs attack every 3 seconds
        };

        dungeon.mobs.activeMobs.push(mob);
        dungeon.mobs.remaining += 1;
        dungeon.mobs.total += 1;
      }

      // Update storage
      if (this.storageManager) {
        this.storageManager.saveDungeon(dungeon).catch(console.error);
      }
    }
  }

  // ============================================================================
  // USER PARTICIPATION & SELECTION
  // ============================================================================
  async selectDungeon(channelKey) {
    const dungeon = this.activeDungeons.get(channelKey);
    if (!dungeon) {
      this.showToast('Dungeon not found', 'error');
      return;
    }

    // Check if user has HP to join
    if (this.settings.userHP <= 0) {
      this.showToast('üíÄ You need HP to join a dungeon! Wait for HP to regenerate.', 'error');
      return;
    }

    // Check if dungeon is still open
    if (dungeon.completed || dungeon.failed) {
      this.showToast('This dungeon is no longer active', 'error');
      return;
    }

    // Leave previous dungeon
    if (this.settings.userActiveDungeon && this.settings.userActiveDungeon !== channelKey) {
      const prevDungeon = this.activeDungeons.get(this.settings.userActiveDungeon);
      if (prevDungeon) {
        prevDungeon.userParticipating = false;
      }
    }

    dungeon.userParticipating = true;
    this.settings.userActiveDungeon = channelKey;

    // Restart shadow attacks when user rejoins
    this.startShadowAttacks(channelKey);

    this.updateBossHPBar(channelKey);
    this.updateUserHPBar();
    this.showToast(`‚öîÔ∏è Joined ${dungeon.name}!`, 'info');
    this.saveSettings();
    this.closeDungeonModal();
  }

  async processUserAttack(channelKey) {
    const dungeon = this.activeDungeons.get(channelKey);
    if (!dungeon) return;

    if (!dungeon.userParticipating) {
      await this.selectDungeon(channelKey);
    }

    // Attack boss if alive
    if (dungeon.boss.hp > 0) {
      const bossStats = {
        strength: dungeon.boss.strength,
        agility: dungeon.boss.agility,
        intelligence: dungeon.boss.intelligence,
        vitality: dungeon.boss.vitality,
      };
      const userDamage = this.calculateUserDamage(bossStats, dungeon.boss.rank);
      await this.applyDamageToBoss(channelKey, userDamage, 'user');
    } else {
      // Attack mobs
      await this.attackMobs(channelKey, 'user');
    }
  }

  // ============================================================================
  // STAT-BASED COMBAT CALCULATIONS
  // ============================================================================
  /**
   * Calculate HP from vitality stat
   */
  /**
   * Calculate HP from vitality stat and rank
   * Uses TOTAL EFFECTIVE STATS if SoloLevelingStats is available
   */
  calculateHP(vitality, rank = 'E') {
    const rankIndex = this.settings.dungeonRanks.indexOf(rank);
    const baseHP = 100;
    return baseHP + vitality * 10 + rankIndex * 50;
  }

  /**
   * Calculate max mana from intelligence stat
   * Uses TOTAL EFFECTIVE STATS if SoloLevelingStats is available
   */
  calculateMana(intelligence) {
    const baseMana = 100;
    return baseMana + intelligence * 10;
  }

  /**
   * Calculate mob strength from stats and rank
   * Uses ShadowArmy's method if available, otherwise calculates directly
   */
  calculateMobStrength(mobStats, mobRank) {
    if (this.shadowArmy?.calculateShadowStrength) {
      // Use ShadowArmy's calculation method
      return this.shadowArmy.calculateShadowStrength(mobStats, 1);
    }

    // Fallback calculation: sum of stats weighted by rank
    const rankIndex = this.settings.dungeonRanks.indexOf(mobRank);
    const rankMultiplier = 1.0 + rankIndex * 0.5; // E=1.0, D=1.5, SSS=4.5, etc.
    const totalStats = Object.values(mobStats).reduce((sum, val) => sum + (val || 0), 0);
    return totalStats * rankMultiplier;
  }

  /**
   * Regenerate HP and Mana based on user stats
   * HP regen: Based on vitality (1% of max HP per second per 100 vitality)
   * Mana regen: Based on intelligence (1% of max mana per second per 100 intelligence)
   */
  regenerateHPAndMana() {
    if (!this.soloLevelingStats) return;

    // Get total effective stats (including buffs)
    const totalStats =
      this.soloLevelingStats?.getTotalEffectiveStats?.() ||
      this.soloLevelingStats?.settings?.stats ||
      {};
    const vitality = totalStats.vitality || 0;
    const intelligence = totalStats.intelligence || 0;

    // HP regeneration: 1% of max HP per second per 100 vitality
    // Formula: (vitality / 100) * 0.01 * maxHP per second
    if (this.settings.userMaxHP > 0 && this.settings.userHP < this.settings.userMaxHP) {
      const hpRegenRate = (vitality / 100) * 0.01; // 1% per 100 vitality
      const hpRegen = Math.max(1, Math.floor(this.settings.userMaxHP * hpRegenRate));
      this.settings.userHP = Math.min(this.settings.userMaxHP, this.settings.userHP + hpRegen);

      // Sync with SoloLevelingStats if available
      if (this.soloLevelingStats?.settings) {
        this.soloLevelingStats.settings.userHP = this.settings.userHP;
      }
    }

    // Mana regeneration: 1% of max mana per second per 100 intelligence
    // Formula: (intelligence / 100) * 0.01 * maxMana per second
    if (this.settings.userMaxMana > 0 && this.settings.userMana < this.settings.userMaxMana) {
      const manaRegenRate = (intelligence / 100) * 0.01; // 1% per 100 intelligence
      const manaRegen = Math.max(1, Math.floor(this.settings.userMaxMana * manaRegenRate));
      this.settings.userMana = Math.min(
        this.settings.userMaxMana,
        this.settings.userMana + manaRegen
      );

      // Sync with SoloLevelingStats if available
      if (this.soloLevelingStats?.settings) {
        this.soloLevelingStats.settings.userMana = this.settings.userMana;
      }
    }

    // Update HP bar if user is participating in any dungeon
    if (this.settings.userActiveDungeon) {
      this.updateUserHPBar();
    }
  }

  /**
   * Handle user defeat - remove from dungeon and stop shadow attacks
   */
  async handleUserDefeat(channelKey) {
    const dungeon = this.activeDungeons.get(channelKey);

    this.showToast('üíÄ You were defeated!', 'error');

    // Remove user from current dungeon participation
    if (dungeon) {
      dungeon.userParticipating = false;
    }

    // Clear active dungeon
    this.settings.userActiveDungeon = null;

    // Stop all shadow attacks in ALL dungeons (shadows die when user dies)
    this.stopAllShadowAttacks();

    // Clear shadow HP from ALL dungeons (shadows disappear when user dies)
    this.activeDungeons.forEach((dungeon) => {
      dungeon.shadowHP = {};
    });

    // Clear all dead shadows tracking
    this.deadShadows.clear();

    // Show message that user can rejoin if they have HP
    this.showToast(
      'üíÄ Shadow armies have been defeated. Rejoin the dungeon when you have HP to continue.',
      'info'
    );

    this.updateUserHPBar();
    this.saveSettings();
  }

  /**
   * Get user stats (total effective stats including all buffs)
   * This is the main method other plugins should use to get user stats
   */
  getUserStats() {
    if (!this.soloLevelingStats) return null;

    return {
      stats:
        this.soloLevelingStats.getTotalEffectiveStats?.() ||
        this.soloLevelingStats.settings.stats ||
        {},
      rank: this.soloLevelingStats.settings.rank || 'E',
      level: this.soloLevelingStats.settings.level || 1,
      hp: this.soloLevelingStats.settings.userHP,
      maxHP: this.soloLevelingStats.settings.userMaxHP,
      mana: this.soloLevelingStats.settings.userMana,
      maxMana: this.soloLevelingStats.settings.userMaxMana,
    };
  }

  /**
   * Calculate damage dealt by attacker to defender
   * Uses stat interactions: strength (physical), intelligence (magic), agility (crit)
   */
  calculateDamage(attackerStats, defenderStats, attackerRank, defenderRank) {
    const attackerStrength = attackerStats.strength || 0;
    const attackerAgility = attackerStats.agility || 0;
    const attackerIntelligence = attackerStats.intelligence || 0;

    // Base physical damage from strength
    let damage = 10 + attackerStrength * 2;

    // Magic damage from intelligence
    damage += attackerIntelligence * 1.5;

    // Rank multiplier
    const attackerRankIndex = this.settings.dungeonRanks.indexOf(attackerRank);
    const defenderRankIndex = this.settings.dungeonRanks.indexOf(defenderRank);
    const rankDiff = attackerRankIndex - defenderRankIndex;

    if (rankDiff > 0) {
      damage *= 1 + rankDiff * 0.2;
    } else if (rankDiff < 0) {
      damage *= Math.max(0.3, 1 + rankDiff * 0.15);
    }

    // Critical hit chance from agility
    const critChance = Math.min(30, attackerAgility * 2);
    if (Math.random() * 100 < critChance) {
      damage *= 2; // Critical hit!
    }

    // Defense reduction from defender's strength and vitality
    const defenderStrength = defenderStats.strength || 0;
    const defenderVitality = defenderStats.vitality || 0;
    const defense = defenderStrength * 0.5 + defenderVitality * 0.3;
    damage = Math.max(1, damage - defense);

    return Math.max(1, Math.floor(damage));
  }

  /**
   * Calculate user damage to enemy
   * Uses TOTAL EFFECTIVE STATS (including title buffs and shadow buffs)
   */
  calculateUserDamage(enemyStats, enemyRank) {
    if (!this.soloLevelingStats?.settings) {
      return this.calculateDamage(
        { strength: 10, agility: 5, intelligence: 5 },
        enemyStats,
        'E',
        enemyRank
      );
    }

    // Use TOTAL EFFECTIVE STATS (base + title buffs + shadow buffs)
    const userStats =
      this.soloLevelingStats.getTotalEffectiveStats?.() ||
      this.soloLevelingStats.settings.stats ||
      {};
    const userRank = this.soloLevelingStats.settings.rank || 'E';

    return this.calculateDamage(userStats, enemyStats, userRank, enemyRank);
  }

  /**
   * Calculate shadow damage to enemy
   * Uses EFFECTIVE STATS (base + growth stats)
   */
  calculateShadowDamage(shadow, enemyStats, enemyRank) {
    if (!shadow) return 0;

    // Get effective stats (base + growth) from ShadowArmy plugin
    let shadowStats = {
      strength: shadow.strength || 0,
      agility: shadow.agility || 0,
      intelligence: shadow.intelligence || 0,
      vitality: shadow.vitality || 0,
      luck: shadow.luck || 0,
    };

    // If ShadowArmy plugin is available, use its method to get effective stats
    if (this.shadowArmy?.getShadowEffectiveStats) {
      const effectiveStats = this.shadowArmy.getShadowEffectiveStats(shadow);
      shadowStats = {
        strength: effectiveStats.strength || shadowStats.strength,
        agility: effectiveStats.agility || shadowStats.agility,
        intelligence: effectiveStats.intelligence || shadowStats.intelligence,
        vitality: effectiveStats.vitality || shadowStats.vitality,
        luck: effectiveStats.luck || shadowStats.luck,
      };
    } else {
      // Fallback: calculate effective stats manually
      const baseStats = shadow.baseStats || {};
      const growthStats = shadow.growthStats || {};
      shadowStats = {
        strength: (baseStats.strength || 0) + (growthStats.strength || 0),
        agility: (baseStats.agility || 0) + (growthStats.agility || 0),
        intelligence: (baseStats.intelligence || 0) + (growthStats.intelligence || 0),
        vitality: (baseStats.vitality || 0) + (growthStats.vitality || 0),
        luck: (baseStats.luck || 0) + (growthStats.luck || 0),
      };
    }

    const shadowRank = shadow.rank || 'E';

    let damage = this.calculateDamage(shadowStats, enemyStats, shadowRank, enemyRank);

    // Role bonuses
    if (shadow.role === 'Tank') damage *= 0.8;
    else if (shadow.role === 'Assassin') damage *= 1.3;
    else if (shadow.role === 'Mage') damage *= 1.2;

    return Math.max(1, Math.floor(damage));
  }

  /**
   * Calculate enemy (boss/mob) damage to target
   */
  calculateEnemyDamage(enemyStats, targetStats, enemyRank, targetRank) {
    return this.calculateDamage(enemyStats, targetStats, enemyRank, targetRank);
  }

  // ============================================================================
  // SHADOW ARMY ATTACKS WITH DEATH SYSTEM
  // ============================================================================
  async startShadowAttacks(channelKey) {
    if (this.shadowAttackIntervals.has(channelKey)) return;
    const interval = setInterval(async () => {
      await this.processShadowAttacks(channelKey);
    }, this.settings.shadowAttackInterval);
    this.shadowAttackIntervals.set(channelKey, interval);
  }

  stopShadowAttacks(channelKey) {
    const interval = this.shadowAttackIntervals.get(channelKey);
    if (interval) {
      clearInterval(interval);
      this.shadowAttackIntervals.delete(channelKey);
    }
  }

  stopAllShadowAttacks() {
    this.shadowAttackIntervals.forEach((interval) => clearInterval(interval));
    this.shadowAttackIntervals.clear();
  }

  startBossAttacks(channelKey) {
    if (this.bossAttackTimers.has(channelKey)) return;
    const timer = setInterval(async () => {
      await this.processBossAttacks(channelKey);
    }, 1000); // Check every second
    this.bossAttackTimers.set(channelKey, timer);
  }

  stopBossAttacks(channelKey) {
    const timer = this.bossAttackTimers.get(channelKey);
    if (timer) {
      clearInterval(timer);
      this.bossAttackTimers.delete(channelKey);
    }
  }

  stopAllBossAttacks() {
    this.bossAttackTimers.forEach((timer) => clearInterval(timer));
    this.bossAttackTimers.clear();
  }

  startMobAttacks(channelKey) {
    if (this.mobAttackTimers.has(channelKey)) return;
    const timer = setInterval(async () => {
      await this.processMobAttacks(channelKey);
    }, 1000); // Check every second
    this.mobAttackTimers.set(channelKey, timer);
  }

  stopMobAttacks(channelKey) {
    const timer = this.mobAttackTimers.get(channelKey);
    if (timer) {
      clearInterval(timer);
      this.mobAttackTimers.delete(channelKey);
    }
  }

  stopAllMobAttacks() {
    this.mobAttackTimers.forEach((timer) => clearInterval(timer));
    this.mobAttackTimers.clear();
  }

  async processShadowAttacks(channelKey) {
    const dungeon = this.activeDungeons.get(channelKey);
    if (!dungeon || dungeon.completed || dungeon.failed) {
      this.stopShadowAttacks(channelKey);
      return;
    }

    if (!this.shadowArmy) return;

    try {
      const allShadows = await this.getAllShadows();
      if (!allShadows || allShadows.length === 0) return;

      const deadShadows = this.deadShadows.get(channelKey) || new Set();
      const shadowHP = dungeon.shadowHP || {}; // Object, not Map

      // Initialize shadow HP if not exists
      for (const shadow of allShadows) {
        if (!shadowHP[shadow.id] && !deadShadows.has(shadow.id)) {
          // Get effective stats (base + growth) for accurate HP calculation
          let shadowVitality = shadow.vitality || shadow.strength || 50;

          // Use ShadowArmy's getShadowEffectiveStats if available
          if (this.shadowArmy?.getShadowEffectiveStats) {
            const effectiveStats = this.shadowArmy.getShadowEffectiveStats(shadow);
            shadowVitality = effectiveStats.vitality || shadowVitality;
          } else {
            // Fallback: calculate effective stats manually
            const baseStats = shadow.baseStats || {};
            const growthStats = shadow.growthStats || {};
            shadowVitality =
              (baseStats.vitality || 0) + (growthStats.vitality || 0) || shadowVitality;
          }

          const maxHP = this.calculateHP(shadowVitality, shadow.rank || 'E');
          shadowHP[shadow.id] = { hp: maxHP, maxHp: maxHP };
        }
      }
      dungeon.shadowHP = shadowHP;

      // Attack boss if alive
      if (dungeon.boss.hp > 0) {
        const bossStats = {
          strength: dungeon.boss.strength,
          agility: dungeon.boss.agility,
          intelligence: dungeon.boss.intelligence,
          vitality: dungeon.boss.vitality,
        };

        for (const shadow of allShadows) {
          if (deadShadows.has(shadow.id)) continue;
          const shadowHPData = shadowHP[shadow.id];
          if (!shadowHPData || shadowHPData.hp <= 0) {
            deadShadows.add(shadow.id);
            continue;
          }

          const shadowDamage = this.calculateShadowDamage(shadow, bossStats, dungeon.boss.rank);
          await this.applyDamageToBoss(channelKey, shadowDamage, 'shadow', shadow.id);
          dungeon.shadowAttacks[shadow.id] = Date.now();
        }
      } else {
        // Attack mobs
        await this.attackMobs(channelKey, 'shadows');
      }

      // Process boss attacks on shadows
      await this.processBossAttacks(channelKey);

      // Process mob attacks on shadows
      await this.processMobAttacks(channelKey);

      this.deadShadows.set(channelKey, deadShadows);
    } catch (error) {
      console.error('Dungeons: Error processing shadow attacks', error);
    }
  }

  async getAllShadows() {
    if (!this.shadowArmy) return [];
    try {
      if (this.shadowArmy.storageManager) {
        return (await this.shadowArmy.storageManager.getShadows({}, 0, 10000)) || [];
      }
      if (this.shadowArmy.settings?.shadows) {
        return this.shadowArmy.settings.shadows || [];
      }
      return [];
    } catch (error) {
      console.error('Dungeons: Error getting all shadows', error);
      return [];
    }
  }

  // ============================================================================
  // BOSS & MOB ATTACKS
  // ============================================================================
  async processBossAttacks(channelKey) {
    const dungeon = this.activeDungeons.get(channelKey);
    if (!dungeon || dungeon.boss.hp <= 0) return;

    const now = Date.now();
    if (now - dungeon.boss.lastAttackTime < dungeon.boss.attackCooldown) return;

    // Regenerate HP and Mana based on stats (runs every second)
    this.regenerateHPAndMana();

    dungeon.boss.lastAttackTime = now;
    const bossStats = {
      strength: dungeon.boss.strength,
      agility: dungeon.boss.agility,
      intelligence: dungeon.boss.intelligence,
      vitality: dungeon.boss.vitality,
    };

    // Boss attacks user if participating
    if (dungeon.userParticipating) {
      // Use TOTAL EFFECTIVE STATS (including title buffs and shadow buffs)
      const userStats = this.getUserStats()?.stats || this.soloLevelingStats?.settings?.stats || {};
      const userRank = this.soloLevelingStats?.settings?.rank || 'E';
      const bossDamage = this.calculateEnemyDamage(
        bossStats,
        userStats,
        dungeon.boss.rank,
        userRank
      );

      this.settings.userHP = Math.max(0, this.settings.userHP - bossDamage);
      this.updateUserHPBar();

      if (this.settings.userHP <= 0) {
        await this.handleUserDefeat(channelKey);
      }
    }

    // Boss attacks shadows
    const allShadows = await this.getAllShadows();
    const shadowHP = dungeon.shadowHP || {}; // Object, not Map
    const deadShadows = this.deadShadows.get(channelKey) || new Set();

    for (const shadow of allShadows) {
      if (deadShadows.has(shadow.id)) continue;
      const shadowHPData = shadowHP[shadow.id];
      if (!shadowHPData || shadowHPData.hp <= 0) {
        deadShadows.add(shadow.id);
        continue;
      }

      const shadowStats = {
        strength: shadow.strength || 0,
        agility: shadow.agility || 0,
        intelligence: shadow.intelligence || 0,
        vitality: shadow.vitality || shadow.strength || 50,
      };
      const shadowRank = shadow.rank || 'E';

      const bossDamage = this.calculateEnemyDamage(
        bossStats,
        shadowStats,
        dungeon.boss.rank,
        shadowRank
      );

      shadowHPData.hp = Math.max(0, shadowHPData.hp - bossDamage);
      shadowHP[shadow.id] = shadowHPData;

      if (shadowHPData.hp <= 0) {
        deadShadows.add(shadow.id);
      }
    }

    dungeon.shadowHP = shadowHP;
    this.deadShadows.set(channelKey, deadShadows);
    this.saveSettings();
  }

  async processMobAttacks(channelKey) {
    const dungeon = this.activeDungeons.get(channelKey);
    if (!dungeon || dungeon.mobs.activeMobs.length === 0) return;

    // Regenerate HP and Mana based on stats (runs every second)
    this.regenerateHPAndMana();

    const now = Date.now();
    const allShadows = await this.getAllShadows();
    const shadowHP = dungeon.shadowHP || {}; // Object, not Map
    const deadShadows = this.deadShadows.get(channelKey) || new Set();

    // Mobs attack shadows
    for (const mob of dungeon.mobs.activeMobs) {
      if (mob.hp <= 0) continue;
      if (now - mob.lastAttackTime < mob.attackCooldown) continue;

      mob.lastAttackTime = now;
      const mobStats = {
        strength: mob.strength,
        agility: mob.agility,
        intelligence: mob.intelligence,
        vitality: mob.vitality,
      };

      // Each mob attacks a random shadow
      const aliveShadows = allShadows.filter(
        (s) => !deadShadows.has(s.id) && shadowHP[s.id]?.hp > 0
      );
      if (aliveShadows.length === 0) break;

      const targetShadow = aliveShadows[Math.floor(Math.random() * aliveShadows.length)];
      const shadowHPData = shadowHP[targetShadow.id];
      if (!shadowHPData) continue;

      const shadowStats = {
        strength: targetShadow.strength || 0,
        agility: targetShadow.agility || 0,
        intelligence: targetShadow.intelligence || 0,
        vitality: targetShadow.vitality || targetShadow.strength || 50,
      };

      const mobDamage = this.calculateEnemyDamage(
        mobStats,
        shadowStats,
        mob.rank,
        targetShadow.rank || 'E'
      );

      shadowHPData.hp = Math.max(0, shadowHPData.hp - mobDamage);
      shadowHP[targetShadow.id] = shadowHPData;

      if (shadowHPData.hp <= 0) {
        deadShadows.add(targetShadow.id);
      }
    }

    dungeon.shadowHP = shadowHP;

    // Mobs attack user if participating
    if (dungeon.userParticipating) {
      const userStats = this.soloLevelingStats?.settings?.stats || {};
      const userRank = this.soloLevelingStats?.settings?.rank || 'E';

      for (const mob of dungeon.mobs.activeMobs) {
        if (mob.hp <= 0) continue;
        if (now - mob.lastAttackTime < mob.attackCooldown) continue;

        const mobStats = {
          strength: mob.strength,
          agility: mob.agility,
          intelligence: mob.intelligence,
          vitality: mob.vitality,
        };

        const mobDamage = this.calculateEnemyDamage(mobStats, userStats, mob.rank, userRank);
        this.settings.userHP = Math.max(0, this.settings.userHP - mobDamage);
        this.updateUserHPBar();

        if (this.settings.userHP <= 0) {
          await this.handleUserDefeat(channelKey);
          break; // Stop processing other mobs after defeat
        }
      }
    }

    this.deadShadows.set(channelKey, deadShadows);
    this.saveSettings();
  }

  async attackMobs(channelKey, source) {
    const dungeon = this.activeDungeons.get(channelKey);
    if (!dungeon || dungeon.mobs.activeMobs.length === 0) return;

    if (source === 'user') {
      // User attacks mobs
      const userStats = this.soloLevelingStats?.settings?.stats || {};
      const userRank = this.soloLevelingStats?.settings?.rank || 'E';

      for (const mob of dungeon.mobs.activeMobs) {
        if (mob.hp <= 0) continue;

        const mobStats = {
          strength: mob.strength,
          agility: mob.agility,
          intelligence: mob.intelligence,
          vitality: mob.vitality,
        };

        const userDamage = this.calculateUserDamage(mobStats, mob.rank);
        mob.hp = Math.max(0, mob.hp - userDamage);

        if (mob.hp <= 0) {
          dungeon.mobs.killed += 1;
          dungeon.mobs.remaining = Math.max(0, dungeon.mobs.remaining - 1);
          if (!this.settings.mobKillNotifications[channelKey]) {
            this.settings.mobKillNotifications[channelKey] = {
              count: 0,
              lastNotification: Date.now(),
            };
          }
          this.settings.mobKillNotifications[channelKey].count += 1;

          // Attempt shadow extraction from dead mob (no cap for dungeons)
          if (this.shadowArmy?.attemptDungeonExtraction) {
            const userStats = this.soloLevelingStats?.settings?.stats || {};
            const userRank = this.soloLevelingStats?.settings?.rank || 'E';
            const userLevel = this.soloLevelingStats?.settings?.level || 1;

            // Calculate mob strength from stats
            const mobStrength = this.calculateMobStrength(mobStats, mob.rank);

            // Attempt extraction (async, don't await to avoid blocking)
            this.shadowArmy
              .attemptDungeonExtraction(
                userRank,
                userLevel,
                userStats,
                mob.rank,
                mobStats,
                mobStrength
              )
              .then((extractedShadow) => {
                if (extractedShadow) {
                  this.showToast(`‚ú® Shadow extracted from ${mob.rank} mob!`, 'success');
                }
              })
              .catch((error) => {
                console.error('[Dungeons] Error extracting shadow from mob:', error);
              });
          }
        }
      }

      // Remove dead mobs
      dungeon.mobs.activeMobs = dungeon.mobs.activeMobs.filter((m) => m.hp > 0);
    } else if (source === 'shadows') {
      // Shadows attack mobs
      const allShadows = await this.getAllShadows();
      const deadShadows = this.deadShadows.get(channelKey) || new Set();
      const shadowHP = dungeon.shadowHP || {};

      for (const shadow of allShadows) {
        if (deadShadows.has(shadow.id)) continue;
        const shadowHPData = shadowHP[shadow.id];
        if (!shadowHPData || shadowHPData.hp <= 0) continue;

        for (const mob of dungeon.mobs.activeMobs) {
          if (mob.hp <= 0) continue;

          const mobStats = {
            strength: mob.strength,
            agility: mob.agility,
            intelligence: mob.intelligence,
            vitality: mob.vitality,
          };

          const shadowDamage = this.calculateShadowDamage(shadow, mobStats, mob.rank);
          mob.hp = Math.max(0, mob.hp - shadowDamage);

          if (mob.hp <= 0) {
            dungeon.mobs.killed += 1;
            dungeon.mobs.remaining = Math.max(0, dungeon.mobs.remaining - 1);

            // Track shadow contribution for XP
            if (!dungeon.shadowContributions[shadow.id]) {
              dungeon.shadowContributions[shadow.id] = { mobsKilled: 0, bossDamage: 0 };
            }
            dungeon.shadowContributions[shadow.id].mobsKilled += 1;

            if (!this.settings.mobKillNotifications[channelKey]) {
              this.settings.mobKillNotifications[channelKey] = {
                count: 0,
                lastNotification: Date.now(),
              };
            }
            this.settings.mobKillNotifications[channelKey].count += 1;

            // Attempt shadow extraction from dead mob (no cap for dungeons)
            if (this.shadowArmy?.attemptDungeonExtraction) {
              const userStats = this.soloLevelingStats?.settings?.stats || {};
              const userRank = this.soloLevelingStats?.settings?.rank || 'E';
              const userLevel = this.soloLevelingStats?.settings?.level || 1;

              // Calculate mob strength from stats
              const mobStrength = this.calculateMobStrength(mobStats, mob.rank);

              // Attempt extraction (async, don't await to avoid blocking)
              this.shadowArmy
                .attemptDungeonExtraction(
                  userRank,
                  userLevel,
                  userStats,
                  mob.rank,
                  mobStats,
                  mobStrength
                )
                .then((extractedShadow) => {
                  if (extractedShadow) {
                    this.showToast(`‚ú® Shadow extracted from ${mob.rank} mob!`, 'success');
                  }
                })
                .catch((error) => {
                  console.error('[Dungeons] Error extracting shadow from mob:', error);
                });
            }
          }
        }
      }

      // Remove dead mobs
      dungeon.mobs.activeMobs = dungeon.mobs.activeMobs.filter((m) => m.hp > 0);
    }

    // Update storage
    if (this.storageManager) {
      this.storageManager.saveDungeon(dungeon).catch(console.error);
    }
    this.saveSettings();
  }

  async applyDamageToBoss(channelKey, damage, source, shadowId = null) {
    const dungeon = this.activeDungeons.get(channelKey);
    if (!dungeon) return;

    dungeon.boss.hp = Math.max(0, dungeon.boss.hp - damage);

    // Track shadow contribution for XP
    if (source === 'shadow' && shadowId) {
      if (!dungeon.shadowContributions[shadowId]) {
        dungeon.shadowContributions[shadowId] = { mobsKilled: 0, bossDamage: 0 };
      }
      dungeon.shadowContributions[shadowId].bossDamage += damage;
    }

    this.updateBossHPBar(channelKey);

    if (dungeon.boss.hp <= 0) {
      await this.completeDungeon(channelKey, 'boss');
    }

    // Update storage
    if (this.storageManager) {
      this.storageManager.saveDungeon(dungeon).catch(console.error);
    }
    this.saveSettings();
  }

  // ============================================================================
  // SHADOW REVIVE SYSTEM
  // ============================================================================
  async reviveShadows(channelKey) {
    const deadShadows = this.deadShadows.get(channelKey);
    if (!deadShadows || deadShadows.size === 0) {
      this.showToast('No dead shadows to revive', 'info');
      return;
    }

    const reviveCost = deadShadows.size * this.settings.shadowReviveCost;
    if (this.settings.userMana < reviveCost) {
      this.showToast(
        `Not enough mana! Need ${reviveCost}, have ${this.settings.userMana}`,
        'error'
      );
      return;
    }

    this.settings.userMana -= reviveCost;

    // Restore shadow HP to full
    const dungeon = this.activeDungeons.get(channelKey);
    if (dungeon) {
      const shadowHP = dungeon.shadowHP || {}; // Object, not Map
      const allShadows = await this.getAllShadows();

      for (const shadowId of deadShadows) {
        const shadow = allShadows.find((s) => s.id === shadowId);
        if (shadow) {
          // Get effective stats (base + growth) for accurate HP calculation
          let shadowVitality = shadow.vitality || shadow.strength || 50;

          // Use ShadowArmy's getShadowEffectiveStats if available
          if (this.shadowArmy?.getShadowEffectiveStats) {
            const effectiveStats = this.shadowArmy.getShadowEffectiveStats(shadow);
            shadowVitality = effectiveStats.vitality || shadowVitality;
          } else {
            // Fallback: calculate effective stats manually
            const baseStats = shadow.baseStats || {};
            const growthStats = shadow.growthStats || {};
            shadowVitality =
              (baseStats.vitality || 0) + (growthStats.vitality || 0) || shadowVitality;
          }

          const maxHP = this.calculateHP(shadowVitality, shadow.rank || 'E');
          shadowHP[shadowId] = { hp: maxHP, maxHp: maxHP };
        }
      }
      dungeon.shadowHP = shadowHP;
    }

    deadShadows.clear();
    this.deadShadows.set(channelKey, deadShadows);
    this.updateUserHPBar();
    this.saveSettings();
    this.showToast(`Revived all shadows! (-${reviveCost} mana)`, 'success');
  }

  // ============================================================================
  // DAMAGE APPLICATION (LEGACY - KEPT FOR COMPATIBILITY)
  // ============================================================================
  async applyDamage(channelKey, damage, source, shadowCount = 0) {
    // Legacy method - redirects to new stat-based system
    const dungeon = this.activeDungeons.get(channelKey);
    if (!dungeon) return;

    if (dungeon.boss.hp > 0) {
      await this.applyDamageToBoss(channelKey, damage, source);
    } else {
      await this.attackMobs(channelKey, source);
    }
  }

  // ============================================================================
  // DUNGEON COMPLETION
  // ============================================================================
  async completeDungeon(channelKey, reason) {
    const dungeon = this.activeDungeons.get(channelKey);
    if (!dungeon) return;

    dungeon.completed = reason !== 'timeout';
    dungeon.failed = reason === 'timeout';

    // Grant XP to shadows based on their contributions
    if (reason === 'boss' || reason === 'complete') {
      await this.grantShadowDungeonXP(channelKey, dungeon);
    }

    this.stopShadowAttacks(channelKey);
    this.stopBossAttacks(channelKey);
    this.stopMobAttacks(channelKey);
    this.stopMobKillNotifications(channelKey);
    this.stopMobSpawning(channelKey);
    this.removeDungeonIndicator(channelKey);
    this.removeBossHPBar(channelKey);

    if (this.settings.userActiveDungeon === channelKey) {
      this.settings.userActiveDungeon = null;
    }

    if (reason === 'complete') {
      this.showToast(`üéâ ${dungeon.name} Cleared!`, 'success');
    } else if (reason === 'boss') {
      this.showToast(`üëë Boss Defeated! ${dungeon.name} Cleared!`, 'success');
    } else if (reason === 'timeout') {
      this.showToast(`‚è∞ ${dungeon.name} Failed (Timeout)`, 'error');
    }

    // Delete from IndexedDB and clear logs
    if (this.storageManager) {
      try {
        await this.storageManager.deleteDungeon(channelKey);
        await this.storageManager.clearCompletedDungeons();
      } catch (error) {
        console.error('Dungeons: Failed to delete dungeon from storage', error);
      }
    }

    this.activeDungeons.delete(channelKey);
    delete this.settings.mobKillNotifications[channelKey];
    this.deadShadows.delete(channelKey);
    this.saveSettings();
  }

  /**
   * Grant XP to shadows based on their dungeon contributions
   * XP is calculated based on:
   * - Dungeon rank (higher rank = more base XP)
   * - Shadow rank (higher rank shadows get more XP per contribution)
   * - Mobs killed (each mob kill = base XP)
   * - Boss damage dealt (damage / boss max HP = contribution percentage)
   *
   * Operations:
   * 1. Get dungeon rank multiplier
   * 2. Calculate base XP reward for dungeon completion
   * 3. For each shadow with contributions:
   *    - Calculate mob kill XP (mobsKilled * baseMobXP)
   *    - Calculate boss damage XP (bossDamage / bossMaxHP * baseBossXP)
   *    - Scale by shadow rank (higher ranks get more XP)
   *    - Grant XP to shadow
   * 4. Show toast notification for shadows that leveled up
   */
  async grantShadowDungeonXP(channelKey, dungeon) {
    if (!this.shadowArmy) return;

    const contributions = dungeon.shadowContributions || {};
    if (Object.keys(contributions).length === 0) return;

    // Get dungeon rank multiplier (higher rank = more XP)
    const dungeonRankIndex = this.settings.dungeonRanks.indexOf(dungeon.rank);
    const dungeonRankMultiplier = 1.0 + dungeonRankIndex * 0.5; // E=1.0, D=1.5, SSS=4.5, etc.

    // Base XP rewards
    const baseMobXP = 10; // Base XP per mob kill
    const baseBossXP = 100; // Base XP for full boss kill

    // Get all shadows to calculate XP
    const allShadows = await this.getAllShadows();
    const shadowMap = new Map(allShadows.map((s) => [s.id, s]));

    let totalXPGranted = 0;
    const leveledUpShadows = [];

    for (const [shadowId, contribution] of Object.entries(contributions)) {
      const shadow = shadowMap.get(shadowId);
      if (!shadow) continue;

      // Get shadow rank multiplier (higher rank shadows get more XP)
      const shadowRank = shadow.rank || 'E';
      const shadowRanks = this.shadowArmy.shadowRanks || [
        'E',
        'D',
        'C',
        'B',
        'A',
        'S',
        'SS',
        'SSS',
        'SSS+',
        'NH',
        'Monarch',
        'Monarch+',
        'Shadow Monarch',
      ];
      const shadowRankIndex = shadowRanks.indexOf(shadowRank);
      const shadowRankMultiplier = 1.0 + shadowRankIndex * 0.3; // E=1.0, D=1.3, SSS=2.4, etc.

      // Calculate mob kill XP
      const mobKillXP = contribution.mobsKilled * baseMobXP;

      // Calculate boss damage XP (proportional to damage dealt)
      const bossMaxHP = dungeon.boss.maxHp || dungeon.boss.hp || 1000;
      const bossDamagePercent = Math.min(1.0, contribution.bossDamage / bossMaxHP);
      const bossDamageXP = bossDamagePercent * baseBossXP;

      // Total XP = (mob kills + boss damage) * dungeon rank * shadow rank
      const totalXP = Math.round(
        (mobKillXP + bossDamageXP) * dungeonRankMultiplier * shadowRankMultiplier
      );

      if (totalXP > 0) {
        // Get shadow's current level before granting XP
        const levelBefore = shadow.level || 1;

        // Grant XP using ShadowArmy's method (grant to specific shadow)
        await this.shadowArmy.grantShadowXP(totalXP, `dungeon_${dungeon.rank}_${channelKey}`, [
          shadowId,
        ]);

        // Check if shadow leveled up
        const levelAfter = shadow.level || 1;
        if (levelAfter > levelBefore) {
          leveledUpShadows.push({ shadow, levelBefore, levelAfter });
        }

        totalXPGranted += totalXP;
      }
    }

    // Show notifications
    if (totalXPGranted > 0) {
      const shadowCount = Object.keys(contributions).length;
      this.showToast(`‚ú® Shadows gained ${totalXPGranted} XP from ${dungeon.name}!`, 'success');
    }

    if (leveledUpShadows.length > 0) {
      for (const { shadow, levelBefore, levelAfter } of leveledUpShadows) {
        this.showToast(
          `‚≠ê ${shadow.roleName || 'Shadow'} (${
            shadow.rank
          }) leveled up: ${levelBefore} ‚Üí ${levelAfter}!`,
          'info'
        );
      }
    }
  }

  // ============================================================================
  // VISUAL INDICATORS (BETTER SVG ICON)
  // ============================================================================
  showDungeonIndicator(channelKey, channelInfo) {
    const channelSelector = `[data-list-item-id="channels___${channelInfo.channelId}"]`;
    const channelElement = document.querySelector(channelSelector);
    if (!channelElement) return;

    const indicator = document.createElement('div');
    indicator.className = 'dungeon-indicator';
    indicator.innerHTML = `
      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#8b5cf6" stroke-width="2">
        <path d="M12 2L2 7L12 12L22 7L12 2Z"></path>
        <path d="M2 17L12 22L22 17"></path>
        <path d="M2 12L12 17L22 12"></path>
      </svg>
    `;
    indicator.title = 'Active Dungeon';
    indicator.style.cssText = `
      position: absolute;
      right: 8px;
      top: 50%;
      transform: translateY(-50%);
      width: 16px;
      height: 16px;
      animation: dungeonPulse 2s infinite;
      z-index: 10;
      cursor: pointer;
    `;

    if (getComputedStyle(channelElement).position === 'static') {
      channelElement.style.position = 'relative';
    }

    channelElement.appendChild(indicator);
    this.dungeonIndicators.set(channelKey, indicator);
  }

  removeDungeonIndicator(channelKey) {
    const indicator = this.dungeonIndicators.get(channelKey);
    if (indicator?.parentNode) {
      indicator.parentNode.removeChild(indicator);
    }
    this.dungeonIndicators.delete(channelKey);
  }

  removeAllIndicators() {
    this.dungeonIndicators.forEach((indicator) => {
      if (indicator?.parentNode) {
        indicator.parentNode.removeChild(indicator);
      }
    });
    this.dungeonIndicators.clear();
  }

  // ============================================================================
  // BOSS HP BAR (IN CHANNEL HEADER)
  // ============================================================================
  updateBossHPBar(channelKey) {
    const dungeon = this.activeDungeons.get(channelKey);
    if (!dungeon || dungeon.boss.hp <= 0) {
      this.removeBossHPBar(channelKey);
      this.showChannelHeaderComments(channelKey);
      return;
    }

    // Only show boss HP bar if user is participating in this dungeon
    if (!dungeon.userParticipating) {
      this.removeBossHPBar(channelKey);
      this.showChannelHeaderComments(channelKey);
      return;
    }

    // Get current channel info to check if this is the active channel
    const currentChannelInfo = this.getChannelInfo();
    const isCurrentChannel =
      currentChannelInfo &&
      currentChannelInfo.channelId === dungeon.channelId &&
      currentChannelInfo.guildId === dungeon.guildId;

    if (!isCurrentChannel) {
      // Not the current channel, remove HP bar if it exists
      this.removeBossHPBar(channelKey);
      this.showChannelHeaderComments(channelKey);
      return;
    }

    // Hide comments in channel header to make room
    this.hideChannelHeaderComments(channelKey);

    const hpPercent = (dungeon.boss.hp / dungeon.boss.maxHp) * 100;
    let hpBar = this.bossHPBars.get(channelKey);

    if (!hpBar) {
      // Find channel header using robust selectors
      const channelHeader = this.findChannelHeader();
      if (!channelHeader) {
        // Retry after delay if header not found
        setTimeout(() => this.updateBossHPBar(channelKey), 500);
        return;
      }

      hpBar = document.createElement('div');
      hpBar.className = 'dungeon-boss-hp-bar';
      hpBar.setAttribute('data-dungeon-boss-hp-bar', channelKey);
      hpBar.style.cssText = `
        display: flex;
        flex-direction: column;
        gap: 6px;
        padding: 8px 12px;
        min-width: 200px;
        max-width: 300px;
        flex: 1;
        margin-left: auto;
      `;

      // Find toolbar or upperContainer to insert into
      const toolbar =
        channelHeader.querySelector('[class*="toolbar"]') ||
        channelHeader.querySelector('[class*="upperContainer"]');

      if (toolbar) {
        toolbar.appendChild(hpBar);
      } else {
        // Fallback: append to channel header
        channelHeader.appendChild(hpBar);
      }

      this.bossHPBars.set(channelKey, hpBar);
    }

    hpBar.innerHTML = `
      <div style="display: flex; flex-direction: column; gap: 4px;">
        <div style="color: #8b5cf6; font-weight: 600; font-size: 12px; text-shadow: 0 0 4px rgba(139, 92, 246, 0.6);">
          ${dungeon.boss.name}
        </div>
        <div style="height: 10px; background: rgba(20, 20, 30, 0.8); border-radius: 5px; overflow: hidden; position: relative;">
          <div style="
            height: 100%;
            width: ${hpPercent}%;
            background: linear-gradient(90deg, #8b5cf6 0%, #7c3aed 50%, #ec4899 100%);
            border-radius: 5px;
            transition: width 0.6s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 0 8px rgba(139, 92, 246, 0.5), inset 0 0 15px rgba(236, 72, 153, 0.3);
          "></div>
          <div style="
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 9px;
            font-weight: 600;
            text-shadow: 0 0 3px rgba(0, 0, 0, 0.9);
            pointer-events: none;
          ">
            ${Math.floor(dungeon.boss.hp)}/${dungeon.boss.maxHp}
          </div>
        </div>
        <div style="color: #999; font-size: 10px;">
          ${dungeon.name} ‚Ä¢ ${dungeon.rank}
        </div>
      </div>
    `;
  }

  /**
   * Find channel header using robust selectors
   */
  findChannelHeader() {
    // Strategy 1: Use aria-label (most stable)
    let header =
      document.querySelector('section[aria-label="Channel header"]') ||
      document.querySelector('section[aria-label*="Channel header"]');

    // Strategy 2: Use semantic class fragments
    if (!header) {
      header =
        document.querySelector('[class*="title"][class*="container"]') ||
        document.querySelector('[class*="channelHeader"]');
    }

    return header;
  }

  /**
   * Hide comments in channel header to make room for boss HP bar
   */
  hideChannelHeaderComments(channelKey) {
    if (this.hiddenComments.has(channelKey)) return; // Already hidden

    // Find comment-related elements in channel header
    const channelHeader = this.findChannelHeader();
    if (!channelHeader) return;

    // Look for comment buttons/elements using multiple strategies
    const allButtons = channelHeader.querySelectorAll('button[class*="button"]');
    const commentElements = [];

    allButtons.forEach((button) => {
      const ariaLabel = (button.getAttribute('aria-label') || '').toLowerCase();
      const className = (button.className || '').toLowerCase();
      const textContent = (button.textContent || '').toLowerCase();

      // Check if it's a comment/thread related button
      const isCommentButton =
        ariaLabel.includes('comment') ||
        ariaLabel.includes('thread') ||
        ariaLabel.includes('reply') ||
        className.includes('comment') ||
        className.includes('thread') ||
        className.includes('reply') ||
        textContent.includes('comment') ||
        textContent.includes('thread');

      // Also check for buttons with SVG icons that might be comment buttons
      const hasIcon = button.querySelector('svg');
      const isInToolbar = button.closest('[class*="toolbar"]');

      if (isCommentButton || (hasIcon && isInToolbar && ariaLabel)) {
        commentElements.push(button);
      }
    });

    // Also look for comment-related elements by class
    const classBasedElements = [
      ...channelHeader.querySelectorAll('[class*="comment"]'),
      ...channelHeader.querySelectorAll('[class*="thread"]'),
      ...channelHeader.querySelectorAll('[class*="reply"]'),
    ].filter((el) => {
      // Make sure it's actually visible and in the toolbar area
      const style = window.getComputedStyle(el);
      return (
        style.display !== 'none' &&
        style.visibility !== 'hidden' &&
        (el.closest('[class*="toolbar"]') || el.closest('[class*="upperContainer"]'))
      );
    });

    // Combine and deduplicate
    const allCommentElements = [...new Set([...commentElements, ...classBasedElements])];

    const hidden = [];
    allCommentElements.forEach((el) => {
      const style = window.getComputedStyle(el);
      if (style.display !== 'none' && style.visibility !== 'hidden') {
        hidden.push({
          element: el,
          originalDisplay: el.style.display || '',
          originalVisibility: el.style.visibility || '',
        });
        el.style.display = 'none';
      }
    });

    if (hidden.length > 0) {
      this.hiddenComments.set(channelKey, hidden);
    }
  }

  /**
   * Show comments in channel header again
   */
  showChannelHeaderComments(channelKey) {
    const hidden = this.hiddenComments.get(channelKey);
    if (!hidden) return;

    hidden.forEach(({ element, originalDisplay, originalVisibility }) => {
      if (element && element.parentNode) {
        element.style.display = originalDisplay || '';
        if (originalVisibility) {
          element.style.visibility = originalVisibility;
        }
      }
    });

    this.hiddenComments.delete(channelKey);
  }

  removeBossHPBar(channelKey) {
    const hpBar = this.bossHPBars.get(channelKey);
    if (hpBar?.parentNode) {
      hpBar.parentNode.removeChild(hpBar);
    }
    this.bossHPBars.delete(channelKey);
    // Restore comments when boss HP bar is removed
    this.showChannelHeaderComments(channelKey);
  }

  removeAllBossHPBars() {
    this.bossHPBars.forEach((hpBar) => {
      if (hpBar?.parentNode) {
        hpBar.parentNode.removeChild(hpBar);
      }
    });
    this.bossHPBars.clear();
  }

  // ============================================================================
  // USER HP/MANA BARS
  // ============================================================================
  createUserHPBar() {
    // User HP/Mana bars are now displayed in SoloLevelingStats chat UI header
    // This method is kept for compatibility but does nothing
    return;
  }

  setupPanelWatcher() {
    if (this.panelWatcher) return;

    // Watch for panel DOM changes and update position if panel moves
    this.panelWatcher = new MutationObserver(() => {
      // If HP bar was removed, recreate it
      if (this.userHPBar && !this.userHPBar.parentNode) {
        this.userHPBar = null;
        this.createUserHPBar();
        return;
      }

      // Update position if panel moved
      if (this.userHPBar && this.userHPBarPositionUpdater) {
        this.userHPBarPositionUpdater();
      }
    });

    // Use multiple strategies to find the panel (most stable first)
    const panel =
      document.querySelector('section[aria-label="User area"]') ||
      document.querySelector('section[aria-label*="User"]') ||
      document.querySelector('[class^="panels_"]') ||
      document.querySelector('[class*="panels"]');
    if (panel) {
      this.panelWatcher.observe(panel, {
        childList: true,
        subtree: true,
        attributes: true,
        attributeFilter: ['style', 'class'],
      });
    }

    // Also observe body for panel changes
    this.panelWatcher.observe(document.body, { childList: true, subtree: true });
  }

  stopPanelWatcher() {
    if (this.panelWatcher) {
      this.panelWatcher.disconnect();
      this.panelWatcher = null;
    }
    if (this.userHPBarPositionInterval) {
      clearInterval(this.userHPBarPositionInterval);
      this.userHPBarPositionInterval = null;
    }
    if (this.userHPBarPositionUpdater) {
      window.removeEventListener('resize', this.userHPBarPositionUpdater);
      window.removeEventListener('scroll', this.userHPBarPositionUpdater);
      this.userHPBarPositionUpdater = null;
    }
  }

  updateUserHPBar() {
    // User HP/Mana bars are now displayed in SoloLevelingStats chat UI header
    // This method is kept for compatibility but does nothing
    return;
  }

  removeUserHPBar() {
    // User HP/Mana bars are now displayed in SoloLevelingStats chat UI header
    // This method is kept for compatibility but does nothing
    if (this.userHPBar) {
      this.userHPBar.remove();
      this.userHPBar = null;
    }
    this.stopPanelWatcher();
  }

  // ============================================================================
  // DUNGEON SELECTION UI (CHAT BUTTON)
  // ============================================================================
  findToolbar() {
    // Method 1: Look for existing TitleManager or SkillTree buttons to find toolbar
    const titleBtn = document.querySelector('.tm-title-button');
    const skillTreeBtn = document.querySelector('.st-skill-tree-button');
    if (titleBtn && titleBtn.parentElement) {
      return titleBtn.parentElement;
    }
    if (skillTreeBtn && skillTreeBtn.parentElement) {
      return skillTreeBtn.parentElement;
    }

    // Method 2: Find by looking for common Discord button classes
    const buttonRow =
      Array.from(document.querySelectorAll('[class*="button"]')).find((el) => {
        const siblings = Array.from(el.parentElement?.children || []);
        return (
          siblings.length >= 4 &&
          siblings.some(
            (s) =>
              s.querySelector('[class*="emoji"]') ||
              s.querySelector('[class*="gif"]') ||
              s.querySelector('[class*="attach"]') ||
              s.classList.contains('tm-title-button') ||
              s.classList.contains('st-skill-tree-button')
          )
        );
      })?.parentElement ||
      (() => {
        const textArea =
          document.querySelector('[class*="channelTextArea"]') ||
          document.querySelector('[class*="slateTextArea"]') ||
          document.querySelector('textarea[placeholder*="Message"]');
        if (!textArea) return null;
        let container =
          textArea.closest('[class*="container"]') ||
          textArea.closest('[class*="wrapper"]') ||
          textArea.parentElement?.parentElement?.parentElement;
        const buttons = container?.querySelectorAll('[class*="button"]');
        if (buttons && buttons.length >= 4) {
          return buttons[0]?.parentElement;
        }
        return (
          container?.querySelector('[class*="buttons"]') ||
          container?.querySelector('[class*="buttonContainer"]') ||
          container?.querySelector('[class*="toolbar"]')
        );
      })();
    return buttonRow;
  }

  createDungeonButton() {
    // Remove existing button first to avoid duplicates
    const existingDungeonBtn = document.querySelector('.dungeons-plugin-button');
    if (existingDungeonBtn) existingDungeonBtn.remove();
    this.dungeonButton = null;

    const toolbar = this.findToolbar();
    if (!toolbar) {
      // Retry with exponential backoff
      const retryCount = (this._dungeonButtonRetryCount || 0) + 1;
      this._dungeonButtonRetryCount = retryCount;
      const delay = Math.min(1000 * retryCount, 5000);
      setTimeout(() => {
        this.createDungeonButton();
      }, delay);
      return;
    }
    this._dungeonButtonRetryCount = 0;

    // Create Dungeons button with proper SVG (dungeon entrance/castle gate icon)
    const button = document.createElement('button');
    button.className = 'dungeons-plugin-button';
    button.innerHTML = `
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M4 6h16M4 6v12M20 6v12M8 6v12M16 6v12"></path>
        <path d="M6 10h4M14 10h4"></path>
        <path d="M12 2v4"></path>
        <circle cx="10" cy="14" r="1" fill="currentColor"></circle>
        <circle cx="14" cy="14" r="1" fill="currentColor"></circle>
      </svg>
    `;
    button.title = 'Dungeons';
    button.setAttribute('aria-label', 'Dungeons');
    button.addEventListener('click', (e) => {
      e.stopPropagation();
      e.preventDefault();
      console.log('[Dungeons] Button clicked - opening dungeon modal');
      console.log('[Dungeons] Debug - activeDungeons Map:', {
        size: this.activeDungeons?.size || 0,
        keys: Array.from(this.activeDungeons?.keys() || []),
        values: Array.from(this.activeDungeons?.values() || []).map((d) => ({
          name: d.name,
          channelKey: d.channelKey,
          completed: d.completed,
          failed: d.failed,
        })),
      });
      this.openDungeonModal();
    });

    const skillTreeBtn = toolbar.querySelector('.st-skill-tree-button');
    const titleBtn = toolbar.querySelector('.tm-title-button');
    const shadowArmyBtn = toolbar.querySelector('.shadow-army-button');
    const appsButton = Array.from(toolbar.children).find(
      (el) =>
        el.querySelector('[class*="apps"]') ||
        el.getAttribute('aria-label')?.toLowerCase().includes('app')
    );

    // Insert Dungeons button after ShadowArmy button (if exists), or after Skill Tree
    let inserted = false;

    if (shadowArmyBtn && shadowArmyBtn.parentElement === toolbar) {
      // Insert after ShadowArmy button
      toolbar.insertBefore(button, shadowArmyBtn.nextSibling);
      inserted = true;
    } else if (skillTreeBtn && skillTreeBtn.parentElement === toolbar) {
      // Insert after Skill Tree button
      toolbar.insertBefore(button, skillTreeBtn.nextSibling);
      inserted = true;
    } else if (titleBtn && titleBtn.parentElement === toolbar) {
      // Insert after Title button
      toolbar.insertBefore(button, titleBtn.nextSibling);
      inserted = true;
    } else if (appsButton && appsButton.parentElement === toolbar) {
      // Insert before apps button
      toolbar.insertBefore(button, appsButton);
      inserted = true;
    }

    // Fallback: append to end if couldn't find reference buttons
    if (!inserted) {
      toolbar.appendChild(button);
    }

    // Store reference
    this.dungeonButton = button;

    // Ensure button is visible
    button.style.display = 'flex';

    // Observe toolbar for changes
    this.observeToolbar(toolbar);

    console.log('[Dungeons] Dungeon button created:', {
      dungeonButton: !!this.dungeonButton,
      toolbar: !!toolbar,
    });
  }

  observeToolbar(toolbar) {
    if (this.toolbarObserver) {
      this.toolbarObserver.disconnect();
    }

    // Check if button exists in toolbar
    const checkButton = () => {
      const dungeonBtnExists = this.dungeonButton && toolbar.contains(this.dungeonButton);

      if (!dungeonBtnExists) {
        this.createDungeonButton();
      }
    };

    this.toolbarObserver = new MutationObserver(() => {
      checkButton();
    });

    this.toolbarObserver.observe(toolbar, { childList: true, subtree: true });

    // Also check periodically as fallback
    if (this.toolbarCheckInterval) {
      clearInterval(this.toolbarCheckInterval);
    }
    this.toolbarCheckInterval = setInterval(checkButton, 2000);
  }

  removeDungeonButton() {
    if (this.dungeonButton) {
      this.dungeonButton.remove();
      this.dungeonButton = null;
    }
    if (this.toolbarObserver) {
      this.toolbarObserver.disconnect();
      this.toolbarObserver = null;
    }
    if (this.toolbarCheckInterval) {
      clearInterval(this.toolbarCheckInterval);
      this.toolbarCheckInterval = null;
    }
  }

  openDungeonModal() {
    console.log('[Dungeons] openDungeonModal() called');
    console.log('[Dungeons] Debug - Checking for existing modal:', {
      hasModal: !!this.dungeonModal,
      modalInDOM: this.dungeonModal ? document.body.contains(this.dungeonModal) : false,
    });

    if (this.dungeonModal) {
      console.log('[Dungeons] Modal already exists, closing it');
      this.closeDungeonModal();
      return;
    }

    console.log('[Dungeons] Debug - Checking active dungeons:', {
      activeDungeonsMap: this.activeDungeons,
      mapSize: this.activeDungeons?.size || 0,
      mapType: typeof this.activeDungeons,
      isMap: this.activeDungeons instanceof Map,
    });

    const dungeons = Array.from(this.activeDungeons.values());
    console.log('[Dungeons] Debug - Dungeons array:', {
      length: dungeons.length,
      dungeons: dungeons.map((d) => ({
        name: d?.name,
        channelKey: d?.channelKey,
        completed: d?.completed,
        failed: d?.failed,
      })),
    });

    if (dungeons.length === 0) {
      console.log('[Dungeons] No active dungeons found - showing toast');
      console.log('[Dungeons] Debug - showToast method:', {
        exists: typeof this.showToast === 'function',
        toastsPlugin: !!this.toasts,
        toastsShowToast: typeof this.toasts?.showToast === 'function',
        method: this.showToast.toString().substring(0, 100),
      });
      const toastResult = this.showToast('No active dungeons', 'info');
      console.log('[Dungeons] Debug - showToast result:', toastResult);
      console.log('[Dungeons] Debug - After showToast call, checking if toast was shown');
      return;
    }

    console.log('[Dungeons] Active dungeons found, creating modal');

    // Create modal similar to TitleManager/SkillTree style
    const modal = document.createElement('div');
    modal.className = 'dungeons-modal';
    modal.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.85);
      z-index: 10001;
      display: flex;
      align-items: center;
      justify-content: center;
      backdrop-filter: blur(5px);
    `;

    const modalContent = document.createElement('div');
    modalContent.style.cssText = `
      width: 90%;
      max-width: 700px;
      max-height: 90vh;
      background: #1e1e1e;
      border: 2px solid #8b5cf6;
      border-radius: 12px;
      padding: 20px;
      overflow-y: auto;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
    `;

    // Function to render dungeon list with real-time updates
    const renderDungeonList = () => {
      const currentDungeons = Array.from(this.activeDungeons.values());

      let headerHTML =
        '<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">';
      headerHTML +=
        '<h2 style="color: #8b5cf6; margin: 0;">Active Dungeons (' +
        currentDungeons.length +
        ')</h2>';
      headerHTML +=
        '<button id="close-dungeon-modal" style="background: transparent; border: none; color: #999; font-size: 24px; cursor: pointer; padding: 0; width: 30px; height: 30px;">√ó</button>';
      headerHTML += '</div>';

      let listHTML = '<div id="dungeon-list">';

      const escapeHtml = (str) => {
        if (!str) return '';
        return String(str)
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;')
          .replace(/'/g, '&#039;');
      };

      if (currentDungeons.length === 0) {
        listHTML +=
          '<div style="text-align: center; padding: 40px; color: #999;">No active dungeons</div>';
      } else {
        currentDungeons.forEach((dungeon) => {
          const isActive = this.settings.userActiveDungeon === dungeon.channelKey;
          const elapsed = Date.now() - dungeon.startTime;
          const remaining = Math.max(0, this.settings.dungeonDuration - elapsed);
          const minutes = Math.floor(remaining / 60000);
          const seconds = Math.floor((remaining % 60000) / 1000);
          const mobsKilled = dungeon.mobs?.killed || 0;
          const activeMobs = dungeon.mobs?.activeMobs || [];
          const deadCount = this.deadShadows.get(dungeon.channelKey)?.size || 0;
          const bossHP = dungeon.boss?.hp || 0;
          const bossMaxHP = dungeon.boss?.maxHp || 1;
          const bossHPPercent = Math.floor((bossHP / bossMaxHP) * 100);
          const channelInfo = this.getChannelInfo(dungeon.channelKey);
          const channelName = channelInfo?.name || dungeon.channelKey;
          const bossName = dungeon.boss?.name || 'Unknown';

          const bgColor = isActive ? 'rgba(139, 92, 246, 0.2)' : 'rgba(255, 255, 255, 0.05)';
          const borderColor = isActive ? '#8b5cf6' : '#444';
          const timeStr = minutes + ':' + seconds.toString().padStart(2, '0');

          listHTML +=
            '<div style="background: ' +
            bgColor +
            '; border: 2px solid ' +
            borderColor +
            '; border-radius: 8px; padding: 15px; margin-bottom: 12px;">';
          listHTML +=
            '<div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 8px;">';
          listHTML += '<div style="flex: 1;">';
          listHTML +=
            '<div style="color: #8b5cf6; font-weight: bold; font-size: 16px; margin-bottom: 4px;">' +
            escapeHtml(dungeon.name) +
            '</div>';
          listHTML +=
            '<div style="color: #999; font-size: 12px; margin-bottom: 2px;">Rank: ' +
            dungeon.rank +
            ' ‚Ä¢ Channel: ' +
            escapeHtml(channelName) +
            '</div>';
          listHTML +=
            '<div style="color: #f59e0b; font-size: 11px;">‚è∞ ' + timeStr + ' remaining</div>';
          listHTML += '</div>';
          if (isActive) {
            listHTML +=
              '<div style="color: #8b5cf6; font-size: 12px; font-weight: bold;">ACTIVE</div>';
          }
          listHTML += '</div>';
          listHTML += '<div style="margin-bottom: 8px;">';
          listHTML +=
            '<div style="color: #ec4899; font-size: 11px; margin-bottom: 4px;">Boss: ' +
            escapeHtml(bossName) +
            ' (' +
            Math.floor(bossHP) +
            '/' +
            Math.floor(bossMaxHP) +
            ' HP)</div>';
          listHTML +=
            '<div style="background: #1a1a1a; border-radius: 4px; height: 12px; overflow: hidden; position: relative;">';
          listHTML +=
            '<div style="background: linear-gradient(90deg, #8b5cf6 0%, #ec4899 100%); height: 100%; width: ' +
            bossHPPercent +
            '%; transition: width 0.3s ease;"></div>';
          listHTML +=
            '<div style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; display: flex; align-items: center; justify-content: center; color: white; font-size: 9px; font-weight: bold; text-shadow: 0 0 3px rgba(0,0,0,0.9);">' +
            bossHPPercent +
            '%</div>';
          listHTML += '</div>';
          listHTML += '</div>';
          listHTML +=
            '<div style="color: #999; font-size: 11px; margin-bottom: 8px;">üëπ Mobs: ' +
            activeMobs.length +
            ' alive ‚Ä¢ ' +
            mobsKilled +
            ' killed';
          if (deadCount > 0) {
            listHTML += ' ‚Ä¢ üíÄ ' + deadCount + ' dead shadows';
          }
          listHTML += '</div>';
          if (!isActive) {
            listHTML +=
              '<button class="join-dungeon-btn" data-channel-key="' +
              dungeon.channelKey +
              '" style="width: 100%; padding: 8px; background: #8b5cf6; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: bold; transition: background 0.2s;">Join Dungeon</button>';
          }
          listHTML += '</div>';
        });
      }

      listHTML += '</div>';
      modalContent.innerHTML = headerHTML + listHTML;
    };

    // Initial render
    renderDungeonList();

    // Append modal content to modal
    modal.appendChild(modalContent);

    // Update every second for real-time timer and HP updates
    const updateInterval = setInterval(() => {
      if (!this.dungeonModal || !document.body.contains(modal)) {
        clearInterval(updateInterval);
        return;
      }
      renderDungeonList();
    }, 1000);

    document.body.appendChild(modal);
    this.dungeonModal = modal;

    // Close button
    modalContent.querySelector('#close-dungeon-modal').addEventListener('click', () => {
      clearInterval(updateInterval);
      this.closeDungeonModal();
    });

    // Join buttons (delegated event listener for dynamic updates)
    modalContent.addEventListener('click', (e) => {
      if (e.target.classList.contains('join-dungeon-btn')) {
        const channelKey = e.target.getAttribute('data-channel-key');
        this.selectDungeon(channelKey);
      }
    });

    // Add hover effects to join buttons
    modalContent.addEventListener('mouseover', (e) => {
      if (e.target.classList.contains('join-dungeon-btn')) {
        e.target.style.background = '#7c3aed';
      }
    });
    modalContent.addEventListener('mouseout', (e) => {
      if (e.target.classList.contains('join-dungeon-btn')) {
        e.target.style.background = '#8b5cf6';
      }
    });

    // Click outside to close
    modal.addEventListener('click', (e) => {
      if (e.target === modal) {
        clearInterval(updateInterval);
        this.closeDungeonModal();
      }
    });
  }

  closeDungeonModal() {
    if (this.dungeonModal) {
      this.dungeonModal.remove();
      this.dungeonModal = null;
    }
  }

  setupChannelWatcher() {
    let lastChannelKey = null;

    const checkChannel = () => {
      const channelInfo = this.getChannelInfo();
      if (!channelInfo) return;

      const currentChannelKey = `${channelInfo.guildId}_${channelInfo.channelId}`;

      // If channel changed, update all boss HP bars and indicators
      if (currentChannelKey !== lastChannelKey) {
        lastChannelKey = currentChannelKey;

        // Update indicators when channel changes
        this.updateAllIndicators();
        this.updateUserHPBar();

        // Update boss HP bars for all active dungeons
        this.activeDungeons.forEach((dungeon, channelKey) => {
          this.updateBossHPBar(channelKey);
        });
      }
    };

    // Check immediately
    checkChannel();

    // Watch for URL changes
    let lastUrl = window.location.href;
    const urlObserver = new MutationObserver(() => {
      const currentUrl = window.location.href;
      if (currentUrl !== lastUrl) {
        lastUrl = currentUrl;
        setTimeout(() => {
          checkChannel();
          // Recreate button when channel changes (Discord may recreate toolbar)
          if (!this.dungeonButton) {
            this.createDungeonButton();
          }
        }, 100);
      }
    });

    urlObserver.observe(document, { childList: true, subtree: true });

    // Also listen to popstate for browser navigation
    this._popstateHandler = () => {
      setTimeout(() => {
        checkChannel();
        // Recreate button when navigating
        if (!this.dungeonButton) {
          this.createDungeonButton();
        }
      }, 100);
    };
    window.addEventListener('popstate', this._popstateHandler);

    // Also watch channel header for changes
    const headerObserver = new MutationObserver(() => {
      checkChannel();
    });

    // Start observing when header is available
    const startHeaderObserver = () => {
      const header = this.findChannelHeader();
      if (header) {
        headerObserver.observe(header, { childList: true, subtree: true });
      } else {
        setTimeout(startHeaderObserver, 1000);
      }
    };
    startHeaderObserver();

    // Also use interval as fallback
    this.channelWatcherInterval = setInterval(checkChannel, 1000);
    this.channelWatcher = { urlObserver, headerObserver };
  }

  stopChannelWatcher() {
    if (this.channelWatcher) {
      if (this.channelWatcher.urlObserver) {
        this.channelWatcher.urlObserver.disconnect();
      }
      if (this.channelWatcher.headerObserver) {
        this.channelWatcher.headerObserver.disconnect();
      }
      this.channelWatcher = null;
    }
    if (this.channelWatcherInterval) {
      clearInterval(this.channelWatcherInterval);
      this.channelWatcherInterval = null;
    }
  }

  updateAllIndicators() {
    this.activeDungeons.forEach((dungeon, channelKey) => {
      const channelInfo = { channelId: dungeon.channelId, guildId: dungeon.guildId };
      this.removeDungeonIndicator(channelKey);
      this.showDungeonIndicator(channelKey, channelInfo);
    });
  }

  // ============================================================================
  // MOB KILL NOTIFICATIONS
  // ============================================================================
  startMobKillNotifications(channelKey) {
    if (this.mobKillNotificationTimers.has(channelKey)) return;
    const timer = setInterval(() => {
      this.showMobKillSummary(channelKey);
    }, this.settings.mobKillNotificationInterval);
    this.mobKillNotificationTimers.set(channelKey, timer);
  }

  stopMobKillNotifications(channelKey) {
    const timer = this.mobKillNotificationTimers.get(channelKey);
    if (timer) {
      clearInterval(timer);
      this.mobKillNotificationTimers.delete(channelKey);
    }
  }

  stopAllDungeonCleanup() {
    this.mobKillNotificationTimers.forEach((timer) => clearInterval(timer));
    this.mobKillNotificationTimers.clear();
    this.stopAllMobSpawning();
    if (this.dungeonCleanupInterval) {
      clearInterval(this.dungeonCleanupInterval);
      this.dungeonCleanupInterval = null;
    }
  }

  showMobKillSummary(channelKey) {
    const notification = this.settings.mobKillNotifications[channelKey];
    if (!notification || notification.count === 0) return;
    const dungeon = this.activeDungeons.get(channelKey);
    if (!dungeon) return;
    const count = notification.count;
    notification.count = 0;
    notification.lastNotification = Date.now();
    this.showToast(`‚öîÔ∏è Killed ${count} mob${count !== 1 ? 's' : ''} in ${dungeon.name}`, 'info');
    this.saveSettings();
  }

  // ============================================================================
  // CLEANUP LOOP
  // ============================================================================
  startDungeonCleanupLoop() {
    if (this.dungeonCleanupInterval) return;
    this.dungeonCleanupInterval = setInterval(() => {
      this.cleanupExpiredDungeons();
    }, 60000);
  }

  cleanupExpiredDungeons() {
    const now = Date.now();
    const expiredChannels = [];
    this.activeDungeons.forEach((dungeon, channelKey) => {
      const elapsed = now - dungeon.startTime;
      if (elapsed >= this.settings.dungeonDuration) {
        expiredChannels.push(channelKey);
      }
    });
    expiredChannels.forEach((channelKey) => {
      this.completeDungeon(channelKey, 'timeout');
    });
  }

  // ============================================================================
  // RESTORE ACTIVE DUNGEONS
  // ============================================================================
  async restoreActiveDungeons() {
    if (!this.storageManager) return;
    try {
      const savedDungeons = await this.storageManager.getAllDungeons();
      for (const dungeon of savedDungeons) {
        const elapsed = Date.now() - dungeon.startTime;
        if (elapsed < this.settings.dungeonDuration && !dungeon.completed && !dungeon.failed) {
          // Ensure activeMobs array exists
          if (!dungeon.mobs.activeMobs) {
            dungeon.mobs.activeMobs = [];
          }
          // Ensure shadowHP object exists
          if (!dungeon.shadowHP) {
            dungeon.shadowHP = {};
          }
          // Convert shadowHP from Map to Object if needed (for compatibility)
          if (dungeon.shadowHP instanceof Map) {
            const shadowHPObj = {};
            dungeon.shadowHP.forEach((value, key) => {
              shadowHPObj[key] = value;
            });
            dungeon.shadowHP = shadowHPObj;
          }

          this.activeDungeons.set(dungeon.channelKey, dungeon);
          const channelInfo = { channelId: dungeon.channelId, guildId: dungeon.guildId };
          this.showDungeonIndicator(dungeon.channelKey, channelInfo);
          this.startShadowAttacks(dungeon.channelKey);
          this.startBossAttacks(dungeon.channelKey);
          this.startMobAttacks(dungeon.channelKey);
          this.startMobKillNotifications(dungeon.channelKey);
          this.startMobSpawning(dungeon.channelKey);
          if (dungeon.userParticipating) {
            this.updateBossHPBar(dungeon.channelKey);
            this.updateUserHPBar();
          }
        } else {
          // Expired, delete it
          await this.storageManager.deleteDungeon(dungeon.channelKey);
        }
      }
    } catch (error) {
      console.error('Dungeons: Failed to restore dungeons', error);
    }
  }

  // ============================================================================
  // TOAST & CSS
  // ============================================================================
  showToast(message, type = 'info') {
    // Try to reload plugin reference if not available
    if (!this.toasts) {
      const toastsPlugin = BdApi.Plugins.get('SoloLevelingToasts');
      if (toastsPlugin?.instance) {
        this.toasts = toastsPlugin.instance;
        console.log('[Dungeons] Toast plugin loaded on-demand');
      }
    }

    if (this.toasts?.showToast) {
      try {
        const result = this.toasts.showToast(message, type);
        return result;
      } catch (error) {
        console.error('[Dungeons] Error showing toast via plugin:', error);
        // Fall back to fallback toast
        this.showFallbackToast(message, type);
        return null;
      }
    } else {
      // Fallback: Create a visual notification
      this.showFallbackToast(message, type);
      return null;
    }
  }

  showFallbackToast(message, type = 'info') {
    // Initialize toast container if it doesn't exist
    if (!this.fallbackToastContainer) {
      this.fallbackToastContainer = document.createElement('div');
      this.fallbackToastContainer.id = 'dungeons-fallback-toast-container';
      this.fallbackToastContainer.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        z-index: 10002;
        display: flex;
        flex-direction: column;
        gap: 10px;
        pointer-events: none;
        max-width: 350px;
      `;
      document.body.appendChild(this.fallbackToastContainer);
      this.fallbackToasts = [];
    }

    // Color mapping based on type
    const colors = {
      info: { bg: '#8b5cf6', border: '#7c3aed', glow: 'rgba(139, 92, 246, 0.4)' },
      success: { bg: '#10b981', border: '#059669', glow: 'rgba(16, 185, 129, 0.4)' },
      error: { bg: '#ef4444', border: '#dc2626', glow: 'rgba(239, 68, 68, 0.4)' },
      warning: { bg: '#f59e0b', border: '#d97706', glow: 'rgba(245, 158, 11, 0.4)' },
    };
    const color = colors[type] || colors.info;

    // Create toast element
    const toast = document.createElement('div');
    toast.className = 'dungeons-fallback-toast';
    const toastId = `toast-${Date.now()}-${Math.random()}`;
    toast.id = toastId;

    toast.style.cssText = `
      background: linear-gradient(135deg, ${color.bg} 0%, ${color.border} 100%);
      border: 2px solid ${color.border};
      border-radius: 10px;
      padding: 14px 18px;
      color: white;
      font-weight: 600;
      font-size: 14px;
      box-shadow: 0 4px 20px ${color.glow}, 0 2px 8px rgba(0, 0, 0, 0.3);
      animation: dungeonsToastSlideIn 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
      word-wrap: break-word;
      pointer-events: auto;
      cursor: pointer;
      transition: transform 0.2s ease, opacity 0.2s ease;
      backdrop-filter: blur(10px);
    `;
    toast.textContent = message;

    // Add hover effect
    toast.addEventListener('mouseenter', () => {
      toast.style.transform = 'scale(1.02)';
      toast.style.boxShadow = `0 6px 24px ${color.glow}, 0 4px 12px rgba(0, 0, 0, 0.4)`;
    });
    toast.addEventListener('mouseleave', () => {
      toast.style.transform = 'scale(1)';
      toast.style.boxShadow = `0 4px 20px ${color.glow}, 0 2px 8px rgba(0, 0, 0, 0.3)`;
    });

    // Click to dismiss
    toast.addEventListener('click', () => {
      this.removeFallbackToast(toastId);
    });

    // Add animation styles if not already added
    if (!document.getElementById('dungeons-fallback-toast-styles')) {
      const style = document.createElement('style');
      style.id = 'dungeons-fallback-toast-styles';
      style.textContent = `
        @keyframes dungeonsToastSlideIn {
          from {
            transform: translateX(120%);
            opacity: 0;
          }
          to {
            transform: translateX(0);
            opacity: 1;
          }
        }
        @keyframes dungeonsToastSlideOut {
          from {
            transform: translateX(0) scale(1);
            opacity: 1;
          }
          to {
            transform: translateX(120%) scale(0.8);
            opacity: 0;
          }
        }
        .dungeons-fallback-toast:hover {
          transform: scale(1.02) !important;
        }
      `;
      document.head.appendChild(style);
    }

    // Add to container
    this.fallbackToastContainer.appendChild(toast);
    this.fallbackToasts.push({ id: toastId, element: toast });

    // Limit to 5 toasts max
    if (this.fallbackToasts.length > 5) {
      const oldestToast = this.fallbackToasts.shift();
      this.removeFallbackToast(oldestToast.id);
    }

    // Auto-remove after 4 seconds
    setTimeout(() => {
      this.removeFallbackToast(toastId);
    }, 4000);
  }

  removeFallbackToast(toastId) {
    const toastIndex = this.fallbackToasts.findIndex((t) => t.id === toastId);
    if (toastIndex === -1) return;

    const toast = this.fallbackToasts[toastIndex].element;
    toast.style.animation = 'dungeonsToastSlideOut 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55)';
    setTimeout(() => {
      if (toast.parentNode) {
        toast.parentNode.removeChild(toast);
      }
      this.fallbackToasts.splice(toastIndex, 1);
    }, 300);
  }

  injectCSS() {
    const styleId = 'dungeons-plugin-styles';
    if (document.getElementById(styleId)) return;
    const style = document.createElement('style');
    style.id = styleId;
    style.textContent = `
      @keyframes dungeonPulse {
        0%, 100% { opacity: 1; transform: translateY(-50%) scale(1); }
        50% { opacity: 0.7; transform: translateY(-50%) scale(1.1); }
      }
      .dungeon-indicator { cursor: pointer; }
      .dungeons-plugin-button {
        width: 32px;
        height: 32px;
        background: transparent;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        color: var(--interactive-normal, #b9bbbe);
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s ease;
        margin: 0 2px;
        flex-shrink: 0;
        padding: 6px;
        box-sizing: border-box;
      }
      .dungeons-plugin-button svg {
        width: 20px;
        height: 20px;
        transition: all 0.2s ease;
        display: block;
      }
      .dungeons-plugin-button:hover {
        background: var(--background-modifier-hover, rgba(4, 4, 5, 0.6));
        color: var(--interactive-hover, #dcddde);
      }
      .dungeons-plugin-button:hover svg {
        transform: scale(1.1);
      }
      .dungeon-boss-hp-bar, .dungeon-user-hp-bar {
        font-family: 'Nova Flat', sans-serif;
      }
    `;
    document.head.appendChild(style);
  }

  getSettingsPanel() {
    return BdApi.React.createElement(
      'div',
      { style: { padding: '20px' } },
      BdApi.React.createElement('h3', null, 'Dungeons Settings'),
      BdApi.React.createElement(
        'div',
        { style: { marginBottom: '15px' } },
        BdApi.React.createElement(
          'label',
          { style: { display: 'block', marginBottom: '5px' } },
          'Spawn Chance (% per message):'
        ),
        BdApi.React.createElement('input', {
          type: 'number',
          min: 0,
          max: 100,
          value: this.settings.spawnChance,
          onChange: (e) => {
            this.settings.spawnChance = parseFloat(e.target.value) || 10;
            this.saveSettings();
          },
          style: { width: '100px', padding: '5px' },
        })
      ),
      BdApi.React.createElement(
        'div',
        {
          style: { marginTop: '20px', padding: '10px', background: '#1a1a1a', borderRadius: '5px' },
        },
        BdApi.React.createElement('strong', null, 'Active Dungeons: '),
        this.activeDungeons.size
      )
    );
  }
};
